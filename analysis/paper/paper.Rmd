---
title: "Title Goes Here"
author:
  - Myfirstname Mylastname:
      email: fl@oneplace.edu
      institute: [UofO]
      correspondence: true
  - Yourfirstname Yourlastname:
      email: fl@another.edu
      institute: [UofA]
      correspondence: false
institute:
  - UofO: University of One Place
  - UofA: University of Another Place
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  bookdown::pdf_document2:
    fig_height: 7.6
    fig_width: 12.8
  powerpoint_presentation:
    fig_height: 7.6
    fig_width: 12.8
    reference_doc: ../templates/template.pptx
bibliography: references.bib
csl: "../templates/journal-of-archaeological-science.csl" # Insert path for the bib-style
header-includes:
  - \usepackage{subfig}
# abstract: |
#   Text of abstract
# keywords: |
#   keyword 1; keyword 2; keyword 3
# highlights: |
#   These are the highlights. 
---


<!-- cambiarn nomenclatura. Imaginario / real -> pasarlo a nombrar la fase -->

<!-- Chequear con ncep -->


<!-- The following code chunk defines some general settings how code chunks should behave. -->

```{r setup, echo = FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  cache = TRUE,
  comment = "#>",
  cache.extra = 43,
  cache.path = "../cache/paper/",
  fig.path = "../figures/",
  dpi = 300
)

library(metR)
library(data.table)
library(magrittr)
library(ggplot2)
library(tagger)
library(ggperiodic)
library(patchwork)
library(shceof)


theme_set(theme_shceof(base_size = 16))

grid <- theme(panel.grid = element_line(color = "gray10", size = 0.4, linetype = 3))

guide_colorstrip_bottom <- function(width = 25, height = 0.5, ...) {
  guide_colorstrip(title.position = "top", title.hjust = 0.5,
                   barheight = height,
                   barwidth = width, ...)
}

guide_colorsteps_bottom <- function(width = 25, height = 0.5, ...) {
  guide_colorsteps(show.limits = TRUE, even.steps = FALSE,
                   title.position = "top", title.hjust = 0.5,
                   barheight = height,
                   barwidth = width, ...)
}

axis_labs_smol <- theme(axis.text = element_text(size = 6))

pattern_crosshatch <- ggplot2::ggproto("GeomCrosshatch", ggpattern::GeomPolygonPattern)


ggplot2::update_geom_defaults(pattern_crosshatch, 
                              list(pattern = "crosshatch",
                                   pattern_colour = "black",
                                   pattern_fill = "black",
                                   pattern_density = 0.01,
                                   pattern_alpha = 0.2,
                                   pattern_spacing = 0.02))

lab_lev <- AddSuffix(" hPa")
lab_cplx <- c(R = "Real", 
              I = "Imaginary")
lab_PC <- c(PC1 = "EOF1", 
            PC2 = "EOF2")

combine_lists <- function(...) {
  # browser(expr = length(x) != length(y))
  X <- list(...)
  names <- names(X[[1]])
  names(names) <- names
  lapply(names, function(n) {
    unlist(lapply(X, function(x) x[[n]]))
  })
}
```

```{r test-irlba}
has_irlba <- requireNamespace("rilba", quietly = TRUE)
if (has_irlba) {
  stop("If installed, metR::EOF uses irlba, but that package has a bug with complex matrices\n(see: https://github.com/bwlewis/irlba/issues/55). Uninstall irlba with renv::remove(\"irlba\") and try again.")
}

```



```{r read-data}
era5 <- ReadNetCDF(ERA5(), vars = c(hgt = "z",
                                    t = "t"),
                   subset = list(level = list(850, 700, 200, 50),
                                 latitude = -90:10)) %>% 
  normalise_coords() %>% 
  .[season(time) == "SON"] %>%
  .[, .(hgt = mean(hgt), 
        t = mean(t)), by = .(lev, lon, lat, time = seasonally(time))]
```

# Introduction


# Data & Methods 

ERA5, ERA5 BE, ERA 20C

If


# Results


```{r compute-eof-naive}
eof_naive <- era5[lev %in% c(50, 200) & lat %between% c(-90, -20)] %>% 
  # .[, hgt := Anomaly(hgt), by = .(season(time), lon, lat, lev)] %>%
  .[, hgt  := Anomaly(hgt)*sqrt(cos(lat*pi/180)), by = .(time, lev, lat)] %>% 
  .[, .(eof = list(EOF(hgt ~ time | lon + lat, n = 1:4, data = .SD, suffix = "EOF"))), by = lev]

explained <- eof_naive[, eof[[1]]$sdev, by = lev] %>% 
  .[order(lev, EOF)] %>% 
  .[, scales::percent(r2, accuracy = .1)]

```



(ref:cap-eof-naive) Leading 4 EOFs of zonal anomalies of geopotential height at 50 hPa and 200 hPa for the SON trimester and the period 1979 -- 2009.

(ref:subcap-eof-naive) Spatial patterns (arbitrary units). The numbers at the top-left of each panel is the variance explained by each EOF.

(ref:subcap-cor-eof-naive) Coefficient of determination of the temporal index of each EOF between levels. 


```{r cor-eof-naive, fig.cap = "(ref:cap-eof-naive)", fig.subcap = c("(ref:subcap-eof-naive)", "(ref:subcap-cor-eof-naive)"), fig.ncol = 1}
eof_naive[, eof[[1]]$right, by = lev] %>% 
  periodic(lon = c(0, 360)) %>% 
  ggplot(aes(lon, lat)) +
  
  geom_contour_fill(aes(z = hgt, fill = ..level..), 
                    breaks = AnchorBreaks(0, 0.01, exclude = 0)) +
  geom_contour_tanaka(aes(z = hgt), breaks = AnchorBreaks(0, 0.01, exclude = 0)) +
  
  geom_qmap(~.x[lat <= -20]) +
  scale_fill_divergent_discretised(guide = "none")  +
  scale_y_latitude() +
  scale_x_longitude() +
  coord_polar() +
  facet_grid(lev~EOF, labeller = labeller(lev = lab_lev))  +
  axis_labs_smol +
  tagger::tag_facets(tag = "panel", tag_pool = explained, tag_suffix = "") 


eof_naive[, eof[[1]]$left, by = lev] %>% 
  .[, item := paste(lev, EOF, sep = "_")] %>% 
  widyr::pairwise_cor(item, time, hgt) %>% 
  setDT() %>%
  # .[]
  .[tstrsplit(item1, "_")[[1]] != tstrsplit(item2, "_")[[1]], ] %>% 
  .[tstrsplit(item1, "_")[[1]] != 50] %>% 
  .[, item1 := tstrsplit(item1, "_")[[2]]] %>%
  .[, item2 := tstrsplit(item2, "_")[[2]]] %>%
  ggplot(aes(item1, item2)) +
  geom_raster(aes(fill = correlation^2)) +
  shadowtext::geom_shadowtext(aes(label = round(correlation^2, 2)), 
                              color = "black", bg.colour = "white", bg.r = 0.2) +
  scale_fill_gradient(guide = "none", low = "white", high = scales::muted("red"), limits = c(0, 1)) +
  scale_x_discrete("200 hPa") +
  scale_y_discrete("50 hPa") +
  plot_layout(ncol = 1)
```

Figure \@ref(fig:cor-eof-naive-1) show the spatial pattern of the 4 leading EOF of zonal anomalies of geopotential height for 50 hPa and 200 hPa computed separately. The percentages XXX . At 50 hPa, EOF1 and EOF2 on one hand, and EOF3 and EOF4 on the other are clearly pairs of zonal waves with wave numbers 1 and 2-3 respectively shifted by 1/4 wavelength. That is, each group of two EOFs represents the same zonal wave structure that changes in magnitude and location. Similarly, at 200 hPa EOF2 and EOF3 represent the same zonal wave structure with wave number ~3. 

Furthermore, the wave 1 pattern represented by the first two EOFs at 50 hPa is similar to the wave 1 pattern shown as the leading EOF at 200 hPa, and the wave 2-3 pattern represented by the third and fourth EOF at 50 hPa is similar to the wave 3 pattern present in EOF2 and EOF3 at 200 hPa. These similarities suggest some level of joint variability across levels. Figure \@ref(fig:cor-eof-naive-2) shows the coefficient of determination between temporal series of each EOF at each level. EOF3 and EOF4 at 50 hPa are highly correlated with EOF2 and EOF3 at 200 hPa. Not only each pair of EOFs represent a single structure within each level, but they represent a coherent pattern of variability between levels. Similarly, the leading EOF of each level are relatively highly correlated, again suggesting an unique mode of joint variability. 




```{r compute-ceof}
invisible(
  ReadNetCDF(ERA5(), vars = c(hgt = "z"),
             subset = list(latitude = -90:10,
                           level = list(200, 50))) %>%
    normalise_coords() %>%
    .[season(time) == "SON"] %>%
    .[, .(hgt = mean(hgt)), by = .(lev, lon, lat, time = seasonally(time))] %>%
    .[, season := season(time)] %>%
    {
      ceof <<- .[, .(eof = list(compute_ceof(.SD))), by = .(season)]
      ceof_splitted <<-  .[, levs := lev] %>%
        .[, .(eof = list(compute_ceof(.SD, n = 1:3))), by = .(season, levs)]
      
    }
)
```



(ref:cap-splitted) Coefficient of determination of the absolute magnitude of complex EOFs between 200 hPa and 50 hPa computing EOF separatedly for each level. The high correlation between levels for the two leading EOFs justifies treating the pattern as a mode of covariability between the stratosphere and the troposphere and, thus, computing the EOFs using both levels at the same time. (probably not to be shown.) 

```{r corr-ceof-splitted, fig.cap = "(ref:cap-splitted)"}
ceof_splitted[, eof[[1]]$left, by = .(lev = levs)] %>%
  copy() %>%
  .[, mag := abs(hgt)] %>%
  .[, item := paste(lev, PC, sep = "_")] %>%
  widyr::pairwise_cor(item, time, mag) %>%
  setDT() %>%
  # .[]
  .[tstrsplit(item1, "_")[[1]] != tstrsplit(item2, "_")[[1]], ] %>%
  .[tstrsplit(item1, "_")[[1]] != 50] %>%
  .[, item1 := tstrsplit(item1, "_")[[2]]] %>%
  .[, item2 := tstrsplit(item2, "_")[[2]]] %>%
  ggplot(aes(item1, item2)) +
  geom_raster(aes(fill = correlation^2)) +
  shadowtext::geom_shadowtext(aes(label = round(correlation^2, 2)),
                              color = "black", bg.colour = "white", bg.r = 0.2) +
  scale_fill_gradient(guide = "none", low = "white", high = scales::muted("red")) +
  scale_x_discrete("200 hPa") +
  scale_y_discrete("50 hPa")
```




```{r define-plot_ceof}
plot_ceof <- function(data, n = 1:2, formula = lev  ~  PC) {
  
  gdata <- data[, cut(eof[[1]], n)$right, by = .(season)]
  
  var <- data[, cut(eof[[1]], n)$sdev, by = .(season)] %>%
    .[, setNames(paste0(PC, " (", scales::percent(r2), ")"),
                 PC)]
  
  gdata %>%
    ggperiodic::periodic(lon = c(0, 360)) %>%
    ggplot(aes(lon, lat)) +
    
    geom_contour_fill(aes(z = Re(hgt), fill = ..level..),
                      breaks = AnchorBreaks(0, 0.005, exclude = 0)) +
    geom_contour2(aes(z = Im(hgt),  linetype = factor(sign(..level..))),
                  breaks = AnchorBreaks(0, 0.005, exclude = 0)) +
    
    scale_fill_divergent_discretised(guide = "none") +
    
    
    geom_qmap(~ .x[lat <= -20]) +
    scale_x_longitude() +
    scale_y_latitude() +
    scale_linetype_manual(values = c("1" = 1, "-1" = 2), labels = c("1" = "+", "-1" = "-"),
                          guide = "none") +
    facet_grid(formula,
               labeller = labeller(lev = lab_lev,
                                   PC = var)) +
    coord_quickmap(ylim = c(NA, -20)) +
    theme(legend.title = element_blank())
}
```



```{r ceofs, fig.cap = "Leading 2 EOFs of zonal anomalies of geopotential height in 50 hPa and 200 hPa for the SON trimester and the period 1979 -- 2009.", fig.subcap = c("Spatial patterns. Real part in shading, imaginary part in contours.", "Temproal series."), fig.ncol = 1}
ceof[season == "SON"] %>%
  plot_ceof() +
  coord_polar() +
  axis_labs_smol +
  tag_facets(tag = "cr")

ceof %>%
  .[, eof[[1]]$left, by = season] %>%
  sep_ReIm(hgt) %>%
  .[season == "SON"] %>%
  # .[, hgt := scale(hgt), by = .(part, PC)] %>%
  ggplot(aes(time, hgt)) +
  geom_hline(yintercept = 0, size = 0.1, color = "gray30") +
  geom_line(aes(color = part)) +
  scale_x_datetime(NULL) +
  scale_y_continuous("EOF") +
  scale_color_brewer(NULL, palette = "Dark2") +
  facet_grid(PC ~ .) +
  theme(panel.spacing = grid::unit(1.5, "lines"))  +
  ggthemes::geom_rangeframe(sides = "lr", size = 0.1, color = "gray30")
```
Both observations motivate the decision of performing complex EOF jointly between levels. The computation of the EOFs was carried out using data from both levels at the same time, therefore, each complex EOF has a spatial part that depends on longitude, latitude and level, an a temporal part that depends only on time. Figures \@ref(fig:ceofs-1) and \@ref(fig:ceofs-2) show, respectively, the spatial and temporal parts of the first two leading complex EOFs of zonal anomalies of geopotential height at 50 hPa and 200 hPa. In the spatial patterns in Figure \@ref(fig:ceofs-1), the real (in shading) and the imaginary parts (in contour) are in quadrature by construction, so that each EOF describe a single wave-like pattern whose amplitude and position (i.e. phase) is controlled by the magnitude and argument of the complex temporal EOF. 

The wave patterns described by these complex EOFs match the patterns seen in the *navie* EOFs of Figure \@ref(fig: cor-eof-naive-1): The first is a wave 1, while the second is a wave 3. Note that in Figure \@ref(fig:ceofs-2), the real part of EOF1 has non zero mean. This is due to th fact that the geopotential fields that enter into the algorithm are anomalies with respect to the zonal mean (shown in Figure \@ref(fig:mean-anom)), not the time mean. The real part of the first EOF is, therefore, capturing the mean zonally anomalous field *and the variability that projects onto it*.

```{r mean-anom, fig.cap = "Mean SON zonal geopotential height anomalies at (a) 50 hPa and (b) 200 hPa"}
era5 %>% 
  .[, mean(-hgt), by = .(lon, lat, lev)] %>% 
  .[lev %in% c(50, 200)] %>% 
  .[lat <= -20] %>% 
  .[, V2 := V1 - mean(V1), by = .(lat, lev)] %>% 
  periodic(lon = c(0, 360)) %>% 
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = V2), global.breaks = FALSE, breaks = AnchorBreaks(exclude = 0)) +
  geom_contour_tanaka(aes(z = V2), global.breaks = FALSE, breaks = AnchorBreaks(exclude = 0)) +
  geom_qmap(~ .x[lat <= -20]) +
  scale_fill_divergent(NULL, breaks = AnchorBreaks(exclude = 0), 
                       guide = guide_colorstrip_bottom()) +
  scale_x_longitude() +
  scale_y_latitude() +
  facet_grid(~lev, labeller = labeller(lev = lab_lev)) +
  coord_polar() +
  axis_labs_smol +
  tag_facets()
```

(ref:extended-series-cap) Temporal series extended using ERA5 back extended preliminary edition (period 1950 -- 1978) and ERA5 (period 1979 -- 2019) and ERA20C (period 1900 -- 2010). Each series is computed by projecting monthly geopotential height zonal anomalies standardised by level south of 20ºS onto the corresponding spatial pattern. In numbers, the coefficient of determination between the ERA20C-based series and the two ERA5-based series. The ERA5 + ERABC and the ERA20C series are centred and scaled using the mean and standard deviation for their period of overlap (1950 -- 2010).


```{r extended-series, fig.cap = "(ref:extended-series-cap)"}

pattern <- ceof$eof[[1]]$right %>%
  sep_ReIm() %>%
  setnames("hgt", "EOF")

era20c <- ERA20C() %>%
  ReadNetCDF(vars = c(hgt = "z"),
             subset = list(latitude = range(pattern$lat),
                           level = list(200, 50))) %>%
  normalise_coords() %>%
  .[season(time) == "SON"] %>%
  .[, .(hgt = mean(hgt)), by = .(lev, lon, lat, time = seasonally(time))] %>%
  .[, season := season(time)] %>%
  .[, hgt := hgt/sd(hgt), by = .(lev)] %>%
  .[pattern, on = .NATURAL, allow.cartesian = TRUE] %>%
  .[, .(hgt = weighted.mean(hgt*EOF, w = cos(lat*pi/180))),  by = .(part, PC, time)]

era_more <- ERA5_BE() %>%
  ReadNetCDF(vars = c(hgt = "z"),
             subset = list(latitude = range(pattern$lat),
                           level = list(200, 50))) %>%
  rbind(.,
        ReadNetCDF(ERA5(), vars = c(hgt = "z"),
                   subset = list(latitude = range(pattern$lat),
                                 level = list(200, 50)))) %>%
  normalise_coords() %>%
  .[season(time) == "SON"] %>%
  .[, .(hgt = mean(hgt)), by = .(lev, lon, lat, time = seasonally(time))] %>%
  .[, season := season(time)] %>%
  .[, hgt := hgt/sd(hgt), by = .(lev)] %>%
  .[pattern, on = .NATURAL, allow.cartesian = TRUE] %>%
  .[, .(hgt = weighted.mean(hgt*EOF, w = cos(lat*pi/180))),  by = .(part, PC, time)] %>%
  era20c[., on = c("part", "PC", "time")] %>%
  .[, hgt := (i.hgt - mean(i.hgt))/sd(i.hgt)*sd(hgt, na.rm = TRUE) + mean(hgt, na.rm = TRUE),
    by = .(part, PC)] %>%
  .[, i.hgt := NULL]



extended <- rbindlist(list(era20c = era20c,
                           era5 = era_more),  use.names = TRUE, idcol = "dataset")


trends <- extended %>% 
  .[time %between% common_range(time, dataset)] %>% 
  .[, FitLm(hgt, time, se = TRUE), by = .(dataset, part, PC)] %>% 
  rm_intercept() %>% 
  .[, p_val := Pvaluate(estimate, std.error, df)] %>% 
  .[, p_report := report_p(p_val)]

trends_all <- extended %>% 
  .[, FitLm(hgt, time, se = TRUE), by = .(dataset, part, PC)] %>% 
  rm_intercept() %>% 
  .[, p_val := Pvaluate(estimate, std.error, df)] %>% 
  .[, p_report := report_p(p_val)]

periods <- range(extended[time %between% common_range(time, dataset)]$time)
periods <- c(periods[1], lubridate::as_datetime("1979-01-01"), periods[2])

correlations <- extended %>% 
  dcast(time + PC + part ~ dataset, value.var = "hgt") %>% 
  na.omit() %>% {
    d <- .
    rbind(
  d[, .(correlation = cor(era20c, era5)), 
    by = .(PC, part, time = ifelse(year(time) >= 1979, 
                                   as.character(mean(periods[2:3])),
                                   as.character(mean(periods[1:2]))))],
    
    d[, .(correlation = cor(era20c, era5)), 
    by = .(PC, part)] %>% 
    .[, time := as.character(mean(periods[c(1, 3)]))]
    )
  } %>% 

  .[, time := lubridate::as_datetime(time)]



extended %>% 
  copy() %>% 
  .[, ref := time %between% common_range(time, dataset)] %>%
  .[, hgt := (hgt - mean(hgt[ref]))/sd(hgt[ref]), by = .(PC, part, dataset)] %>% 
  .[, dataset_o := dataset] %>% 
  # .[dataset == "era5", dataset := ifelse(year(time) < 1979, "era5be", "era5")] %>% 
  ggplot(aes(time, hgt)) +
  # Zero line + rangeframe
  geom_hline(yintercept = 0, size = 0.1, color = "gray30") +
  ggthemes::geom_rangeframe(sides = "lr", size = 0.1, color = "gray30") +

  geom_line(aes(color = dataset)) +
  scale_alpha_manual(values = c(1, 0.2)) +
  # Correlations
  annotate("errorbarh", xmin = periods[1:2], xmax = periods[2:3], y = -2.7, size = 0.3) +
  annotate("errorbarh", xmin = periods[1], xmax = periods[3], y = -4, size = 0.3) +
  
  geom_label(data = correlations[time %in% range(time)], aes(y = -2.7, label = signif(correlation^2, 2)), 
             label.r = grid::unit(0, "lines"), label.size = 0) +
  geom_label(data = correlations[!(time %in% range(time))], aes(y = -4, label = signif(correlation^2, 2)), 
             label.r = grid::unit(0, "lines"), label.size = 0) +
  
  geom_smooth(data = ~.x[dataset == "era20c"], 
              method = "lm", se = FALSE,  aes(color = dataset)) +
  geom_smooth(data = ~copy(.x)[time %between% common_range(time, dataset)],
              aes(color = dataset), method = "lm", se = FALSE) +
 
  scale_x_datetime(NULL) +
  scale_y_continuous("Standarised EOF") +
  scale_color_brewer(NULL, palette = "Dark2", labels = c(era20c = "ERA20C",
                                                           era5 = "ERA5 BE"),
                     guide = guide_legend(override.aes = list(size = 1), order = 1)) +
  facet_grid(part ~ PC, labeller = labeller(PC = lab_PC)) +
  theme(panel.spacing = grid::unit(1.5, "lines"))  +
  
  tag_facets("cr")
```

Figure \@ref(fig:extended-series) shows temporal series of the two complex EOFs extended beyond the satellite era using the preliminary ERA5 back extension going back to 1950 (which we call the "hybrid ERA5" reanalysis) and using ERA20C for the period 1900 -- 2010. The hybrid ERA5 series and the ERE20C series agree relatively well during the period of overlap, although correlations are higher in the satellite period. There is a slight downwards trend in the real part of EOF1 in the hybrid reanalysis (Figure \@ref(fig:extended-series)a.1, p-value `r trends[part == "Real" & PC == "PC1" & dataset != "era20c"]$p_report` for the period 1950 -- 2010) that appears to be part of a long-term signal, judging by the statistically significant trend observed in the ERA20C reanalysis from 1900 to 2010 (p-value `r trends_all[part == "Real" & PC == "PC1" & dataset == "era20c"]$p_report`) with similar magnitude during the period of overlap. 

The ERA20C time-series has a also significant upward linear trend in the imaginary part of EOF1 (Figure \@(ref:fig-extended-series)a.2, p-value `r trends[part == "Imaginary" & PC == "PC1" & dataset == "era20c"]$p_report`. However, there is no trend in the hybrid dataset during the period of overlap (p-value `r trends[part == "Imaginary" & PC == "PC1" & dataset != "era20c"]$p_report`) and the correlations between the old and modern series are much poorer for this variable. This suggests that the observed trend is not robust. 

There is no significant trend in any of the complex parts of EOF2. The correlations between the hybrid and ERA20C datasets are much higher than for the EOF1, which suggests that ERA20C could be used as a valid dataset to study this index in the past. 


<!-- (ref:extended-magnitude-cap) Same as Figure \@ref(fig:extended-series) but for EOF magnitude defined as $\sqrt{\mathrm{Real}^2 + \mathrm{Imaginary}^2}$.  -->

<!-- ```{r extended-magnitude, fig.cap = "(ref:extended-magnitude-cap)"} -->
<!-- magnitudes <- extended %>%  -->
<!--   copy() %>%  -->
<!--   dcast(time + PC + dataset ~ part, value.var = "hgt") %>%  -->
<!--   .[, ref := time %between% common_range(time, dataset)] %>% -->
<!--   .[, hgt := sqrt(Real^2 + Imaginary^2)] %>%  -->
<!--   .[, hgt := (hgt - mean(hgt[ref]))/sd(hgt[ref]), by = .(PC, dataset)] -->


<!-- correlations_mag <- magnitudes %>%  -->
<!--   dcast(time + PC  ~ dataset, value.var = "hgt") %>%  -->
<!--   na.omit() %>% { -->
<!--     d <- . -->
<!--     rbind( -->
<!--   d[, .(correlation = cor(era20c, era5)),  -->
<!--     by = .(PC, time = ifelse(year(time) >= 1979,  -->
<!--                                    as.character(mean(periods[2:3])), -->
<!--                                    as.character(mean(periods[1:2]))))], -->

<!--     d[, .(correlation = cor(era20c, era5)),  -->
<!--     by = .(PC)] %>%  -->
<!--     .[, time := as.character(mean(periods[c(1, 3)]))] -->
<!--     ) -->
<!--   } %>%  -->

<!--   .[, time := lubridate::as_datetime(time)] -->



<!-- trends_mag <- magnitudes %>%  -->
<!--   .[time %between% common_range(time, dataset)] %>%  -->
<!--   .[, FitLm(hgt, time, se = TRUE), by = .(dataset, PC)] %>%  -->
<!--   rm_intercept() %>%  -->
<!--   .[, p_val := Pvaluate(estimate, std.error, df)] %>%  -->
<!--   .[, p_report := report_p(p_val)] -->

<!-- trends_all_mag <- magnitudes %>%  -->
<!--   .[, FitLm(hgt, time, se = TRUE), by = .(dataset, PC)] %>%  -->
<!--   rm_intercept() %>%  -->
<!--   .[, p_val := Pvaluate(estimate, std.error, df)] %>%  -->
<!--   .[, p_report := report_p(p_val)] -->


<!-- magnitudes %>%  -->
<!--   ggplot(aes(time, hgt)) + -->
<!--   # Zero line + rangeframe -->
<!--   geom_hline(yintercept = 0, size = 0.1, color = "gray30") + -->
<!--   ggthemes::geom_rangeframe(sides = "lr", size = 0.1, color = "gray30") + -->

<!--   geom_line(aes(color = dataset)) + -->

<!--   # Correlations -->
<!--   annotate("errorbarh", xmin = periods[1:2], xmax = periods[2:3], y = -2.7, size = 0.3) + -->
<!--   annotate("errorbarh", xmin = periods[1], xmax = periods[3], y = -4, size = 0.3) + -->

<!--   geom_label(data = correlations_mag[time %in% range(time)], aes(y = -2.7, label = signif(correlation^2, 2)),  -->
<!--              label.r = grid::unit(0, "lines"), label.size = 0) + -->
<!--   geom_label(data = correlations_mag[!(time %in% range(time))], aes(y = -4, label = signif(correlation^2, 2)),  -->
<!--              label.r = grid::unit(0, "lines"), label.size = 0) + -->

<!--     geom_smooth(data = ~.x[dataset == "era20c"],  -->
<!--               method = "lm", se = FALSE,  aes(color = dataset)) + -->
<!--   geom_smooth(data = ~copy(.x)[time %between% common_range(time, dataset)], -->
<!--               aes(color = dataset), method = "lm", se = FALSE) + -->


<!--   scale_x_datetime(NULL) + -->
<!--   scale_y_continuous("Standarised EOF magnitude") + -->
<!--   scale_color_brewer(NULL, palette = "Dark2", labels = c(era20c = "ERA20C", -->
<!--                                                            era5 = "ERA5 BE"), -->
<!--                      guide = guide_legend(override.aes = list(size = 1), order = 1)) + -->
<!--   facet_wrap(~PC, labeller = labeller(PC = lab_PC), ncol = 2) + -->
<!--   theme(panel.spacing = grid::unit(1.5, "lines"))  + -->

<!--   tag_facets() -->
<!-- ``` -->




## Regression



```{r compute-regression}
regr <- ceof[, eof[[1]]$left, by = season] %>%
  .[season == "SON"] %>%
  sep_ReIm(format = "wide") %>%
  .[, hgt := NULL] %>%
  .[, `:=`(R = as.numeric(scale(R)), I = as.numeric(scale(I))), by = .(season, PC)] %>%
  dcast(time ~ PC, value.var = c("R", "I")) %>%
  .[melt(era5, id.vars = c("time", "lon", "lat", "lev")), on = "time", allow.cartesian = TRUE] %>%
  .[lev %in% c(850, 700, 200, 50)] %>%
  # .[variable == "hgt"] %>%
  .[, FitLm(value, I_PC1, R_PC1, I_PC2, R_PC2, se = TRUE), by = .(lev, lon, lat, variable)] %>%
  .[, c("term", "PC") := tstrsplit(term, "_")] %>%
  rm_intercept() %>% 
  .[, term := factor(term, levels = c("R", "I"), labels = c("Real", "Imaginary"))]
```



```{r define-plot_regr}
plot_regr <- function(data, which_PC, which_levs, which_var) {
  data <- data %>%
    .[ PC %in% which_PC] %>%
    .[variable == which_var]
  
  var_title <- switch(which_var, 
                      hgt = "Geopotential height", 
                      t = "Temperature")
  lab_pc <- c(PC1 = "EOF1", PC2 = "EOF2")
  
  
  if (length(which_PC) > 1) {
    facet <- ggh4x::facet_nested(PC ~  term)
  } else {
    facet <- ggh4x::facet_nested(lev ~ PC +  term, labeller = labeller(lev = lab_lev, PC = lab_pc))
  }
  
  if ("lev" %in% colnames(data)) {
    data <- data[lev %in% which_levs]
  } else {
    data[, lev := which_levs]
  }
  data[lat <= -20] %>%
    # .[term == "I" & lev == 50] %>%
    .[, p_val := Pvaluate(estimate, std.error, df, "fdr"), by = .(lev, PC, term)] %>%
    periodic(lon = c(0, 360)) %>%
    ggplot(aes(lon, lat)) +
    ditto(
      geom_contour_fill(aes(z = estimate), breaks = AnchorBreaks(exclude = 0), global.breaks = FALSE) +
        geom_contour_tanaka() +
        scale_fill_divergent(var_title, guide = guide_colorstrip_bottom())
    ) +
    
    geom_contour2(aes(z = p_val), breaks = 0.05, size = 0.1) +
    stat_subset(aes(subset = p_val <= 0.05 & is.cross(lon, lat, 1)),
                geom = "point", size = 0.2, alpha = 0.1) +
    geom_qmap(~ .x[lat <= -20]) +
    
    scale_x_longitude() +
    scale_y_latitude() +
    facet +
    coord_polar() +
    axis_labs_smol +
    tag_facets("rc")
}

```


(ref:eof1-regr-gh-cap) Regression coefficients of the real and imaginary part of the first complex EOF on SON geopotential height for the 1979 -- 2019 period. These coefficients come from multiple linear regression involving the real and imaginary part of both EFO2. 

```{r eof1-regr-gh, fig.cap = "(ref:eof1-regr-gh-cap)"}
plot_regr(regr, "PC1", c(200, 50), "hgt") 
```
Figure \@ref(fig:ref:eof1-regr-gh) shows regression patterns of SON geopotential height on the real and imaginary part of the first EOF at 50 hPa and 200 hPa. 




(ref:eof1-regr-t-cap) Same as Figure \@ref(fig:eof1-regr-gh) but for air temperature.

```{r eof1-regr-t, fig.cap = "(ref:eof1-regr-t-cap)"}
plot_regr(regr, "PC1", c(200, 50), "t") 
```

(ref:eof2-regr-gh-cap) Same as Figure \@ref(fig:eof1-regr-gh) but for the second EOF. 


```{r eof2-regr-gh, fig.cap = "(ref:eof2-regr-gh-cap)"}
plot_regr(regr, "PC2", c(200, 50), "hgt")
```


(ref:eof2-regr-t-cap) Same as Figure \@ref(fig:eof1-regr-gh) but for the second EOF and temperature. 

```{r eof2-regr-t, fig.cap = "(ref:eof2-regr-t-cap)"}
plot_regr(regr, "PC2", c(200, 50), "t")
```





```{r zonal-waves, fig.cap = "Amplitud de ondas zonales de la regresión con altura geopotencial (figuras anteriores)"}
regr %>%
  .[lat <= -20] %>%
  .[lev %in% c(200, 50)] %>%
  # .[PC == "PC1"] %>%
  .[, FitWave(estimate, 0:3), by = .(lev, PC, term, lat)] %>%
  ggplot(aes(lat, amplitude)) +
  geom_line(aes(color = factor(k))) +
  ggh4x::facet_nested(lev + PC ~ term, scales = "free") +
  scale_color_brewer("Wavenumber", palette = "Dark2") +
  scale_y_continuous("Amplitude") +
  scale_x_latitude() +
  coord_flip()
```



Interpretaciones:

* Parte real de EOF1: variabilidady que se proyecta en la dirección del campo medio

* Parte imaginaria de EOF1: variabilidad asociada a la parte simétrica del SAM

* EOF2: PSA1 y PSA2.  
- Parte imaginaria: proyecta sobre la parte asimétrica del SAM (PSA2)
- Parte real: relativamente independiente del SAM

El primer EOF es esencialmente una medida de la variabilidad proyectada en la dirección el campo medio. La parte importante, de todas formas, es la Real. 

## Relationship with other indices



```{r read-indices}
sam <- "/home/elio/Documents/CONICET/asymsam/analysis/data/derived_data/indexes.Rds" %>%
  readRDS() %>%
  .[, .(time, sam = -estimate_norm, lev, symmetry = term)] %>%
  .[, sam := sam/sd(sam), by = .(lev, symmetry)] %>%
  .[season(time) == "SON"] %>%
  .[, .(sam = mean(sam)), by = .(symmetry, lev, time = seasonally(time))]



enso <- rsoi::download_oni(TRUE, data_path("raw", "oni.csv")) %>%
  as.data.table() %>%
  .[, .(time = lubridate::as_datetime(Date), oni = ONI)] %>%
  na.omit() %>%
  .[season(time) == "SON"] %>%
  .[, .(oni = mean(oni)), by = .(time = seasonally(time))]

plot_with_index <- function(ceof, index) {
  index_col <- colnames(index)[2]
  
  ceof[, eof[[1]]$left] %>%
    sep_ReIm() %>%
    .[, hgt := scale(hgt), by = .(PC, part)] %>%
    index[., on = "time"] %>%
    na.omit() %>%
    .[, index := get(index_col)] %>%
    ggplot(aes(hgt, index)) +
    geom_point(aes(color = part)) +
    geom_smooth(aes(color = part), method = "lm") +
    shadowtext::geom_shadowtext(data = ~.x[, .(cor = cor(index, hgt),
                                               x = -1.2,
                                               y = sign(-cor(index, hgt))*.1 + predict(lm(index ~ hgt),
                                                                                       newdata = data.frame(hgt = -1.2))),
                                           by = .(PC, part)],
                                bg.colour = "white", bg.r = 0.2,
                                size = 5,
                                aes(x, y, color = part, label = paste0("r² = ", round(cor^2, 2)))) +
    scale_x_continuous("EOF") +
    scale_y_continuous(toupper(index_col)) +
    scale_color_brewer("Part", palette = "Dark2") +
    facet_grid(part ~ PC, labeller = labeller(PC = c(PC1 = "EOF1", PC2 = "EOF2")))
}
```


```{r sam-eof, fig.cap = "Standarised temporal EOFs and SAM index computed as the leading EOF of geopotential height anomalies at 700 hPa."}
plot_with_index(ceof, sam[lev == 700 & symmetry == "full"][, .(time, sam)])
```

(ref:sam-eof-vertical-cap) Coefficient of determination between the real and imaginary part of each EOF and the SAM, Asymmetric SAM and Symmetric SAM indices computed at each level according to Campitelli on press??. 

```{r sam-eof-vertical, fig.cap = "(ref:sam-eof-vertical-cap)"}
time <- ceof[, eof[[1]]$left] %>%
  sep_ReIm() %>%
  .[, hgt := scale(hgt), by = .(PC, part)] %>%
  .[]


sams <- readRDS(data_path("derived", "sam.Rds"))


sams %>% 
  .[time, on =.NATURAL, allow.cartesian = TRUE] %>%
  na.omit() %>%
  .[, cor(hgt, estimate)^2, by = .(lev, term, part, PC)] %>%
  ggplot(aes(lev, V1)) +
  geom_line(aes(color = term, size = term)) +
  scale_x_level() +
  scale_y_continuous("r²") +
  scale_size_manual(guide = "none",
                    values = c(full = 1,
                               asym = 0.5,
                               sym = 0.5)) +
  scale_color_brewer(NULL, palette = "Dark2", labels = c(full = "SAM",
                                                         asym = "Asymmetric SAM",
                                                         sym = "Symmetric SAM")) +
  facet_grid(part ~ PC, labeller = labeller(PC = c(PC1 = "EOF1", PC2 = "EOF2"))) +
  coord_flip()

```

```{r}
sams <- ERA5() %>% 
  ReadNetCDF(vars = c("hgt" = "z"), 
             subset = list(latitude = c(-90, -20))) %>% 
  normalise_coords() %>% 
  .[season(time) == "SON"] %>% 
  .[, .(hgt = mean(hgt)), by = .(lon, lat, lev, time = seasonally(time))] %>% 
  .[, hgt := Anomaly(hgt), by = .(lon, lat, lev)] %>% 
  .[, asymsam::eof_asym(hgt, lon, lat, time), by = lev]
```

```{r}
sams %>% 
  .[, PC := NULL] %>% 
 .[time, on =.NATURAL, allow.cartesian = TRUE] %>%
  na.omit() %>%
  .[, cor(hgt, estimate)^2, by = .(lev, term, part, PC)] %>%
  ggplot(aes(lev, V1)) +
  geom_line(aes(color = term, size = term)) +
  scale_x_level() +
  scale_y_continuous("r²") +
  scale_size_manual(guide = "none",
                    values = c(full = 1,
                               asym = 0.5,
                               sym = 0.5)) +
  scale_color_brewer(NULL, palette = "Dark2", labels = c(full = "SAM",
                                                         asym = "Asymmetric SAM",
                                                         sym = "Symmetric SAM")) +
  facet_grid(part ~ PC, labeller = labeller(PC = c(PC1 = "EOF1", PC2 = "EOF2"))) +
  coord_flip()

```


(ref:oni-eof-cap) Same as Figure \@ref(fig:sam-eof) but for the Oceanic Enso Index (REF??).

```{r oni-eof, fig.cap = "(ref:oni-eof-cap)"}
plot_with_index(ceof, enso)
```


::: notes

En la tropósfera, la pate imaginaria del PC2 captura la parte asimétrica del SAM.
La parte real es muy parecida en estructura, pero como está desfasada, no coincide con el SAM y entonces no proyecta fuerte en él.

La Parte imaginaria está muy influenciada por ENSO, como se ve en la relación con el íncide y en la regresión con la SST. La fase Real parece no tener influencia del océano tropical. Sin embargo, los flujos de acción de onda.

A su vez, la parte imaginaria del PC1 captura también parte del SAM, pero principalmente la parte simétrica.


:::




```{r compute-psi}
psi <- ReadNetCDF(ERA5(), vars = "vo",
                  subset = list(level = c(50, 200),
                                time = c("1979-01-01", "2019-12-01"))) %>%
  normalise_coords() %>%
  .[season(time) == "SON"] %>%
  .[, .(vo = mean(vo)), by = .(lon, lat, lev,time = seasonally(time))] %>%
  .[, solve_poisson(vo, lon, lat), by = .(lev, time)] %>%
  .[, psi.z := Anomaly(value), by = .(time, lev, lat)] %>%
  .[, value := NULL]
```


```{r regr_psi}
regr_psi <- ceof[, eof[[1]]$left, by = season] %>%
  sep_ReIm(hgt, "wide") %>%
  .[, hgt := NULL] %>%
  .[, `:=`(R = R/sd(R), I = I/sd(I)), by = .(season, PC)] %>%
  .[psi, on = "time", allow.cartesian = TRUE] %>%
  .[season(time) == "SON"] %>%
  .[, FitLm(psi.z, R, I, se = TRUE),by = .(lon, lat, lev, PC, season)] %>%
  rm_intercept() %>%
  .[, psi.z := estimate] %>%
  .[, c("fx", "fy") := shceof::WaveFlux(.SD, p = 200), by = .(lev, PC, season, term)]
```


```{r sst}
sst <- ERA5_SST() %>%
  ReadNetCDF(vars = c("t" = "sst")) %>%
  normalise_coords() %>%
  .[season(time) == "SON"] %>%
  .[, .(t = mean(t)), by = .(lon, lat, time = seasonally(time))]
```

```{r regr_sst}
regr_sst <- ceof[, eof[[1]]$left, by = season] %>%
  sep_ReIm(hgt, "wide") %>%
  .[, hgt := NULL] %>%
  .[, `:=`(R = R/sd(R), I = I/sd(I)), by = .(season, PC)] %>%
  .[sst, on = "time", allow.cartesian = TRUE] %>%
  .[season(time) == "SON"] %>%
  .[, FitLm(t, I, R, se = TRUE), by = .(lon, lat, PC, season)] %>%
  rm_intercept()
```



```{r plot_sst_psi}
plot_sst_psi <- function(which_pc, which_lev) {
  sst_gdata <- regr_sst[PC == which_pc] %>%
    .[lat %between% c(-90, 10)] %>%
    .[, p_val := Pvaluate(estimate, std.error, df, "fdr"), by = .(PC, term)] %>%
    .[, var := "SST"]
  regr_psi %>% 
    .[PC == which_pc] %>%
    .[lev == which_lev] %>%
    # .[abs(estimate) > 1, estimate := NA] %>%
    .[lat %between% c(-90, 10)] %>%
    .[, p_val := Pvaluate(estimate, std.error, df, "fdr"), by = .(PC, term)] %>%
    .[, var := "Streamfunction"] %>% 
    periodic(lon = c(0, 360)) %>%
    ggplot(aes(lon, lat)) +
    geom_contour_fill(aes(z = estimate*1e8, fill = ..level..),  breaks = AnchorBreaks(exclude = 0)) +
    geom_contour2(aes(z = p_val), breaks = 0.05, size = 0.1) +
    stat_subset(aes(subset = p_val <= 0.05 & is.cross(lon, lat, 2)),
                geom = "point", size = 0.2, alpha = 0.5) +
    geom_streamline(aes(dx = fx, dy = fy), min.L = 3, L = 10, n = 30,
                    size = 0.2, res = 2) +
    geom_qmap(keep = .015) +
    scale_fill_divergent_discretised("Streamfunction", guide = "none") +
    ggnewscale::new_scale_fill() +
    
    geom_contour_fill(data = sst_gdata,
                      aes(z = estimate, fill = ..level..), breaks = AnchorBreaks(exclude = 0)) +
    geom_contour_tanaka(data = sst_gdata, 
                        aes(z = estimate), breaks = AnchorBreaks(exclude = 0)) +
    geom_contour2(data = sst_gdata, 
                  aes(z = p_val), breaks = 0.05, size = 0.1) +
    stat_subset(data = sst_gdata,
                aes(subset = p_val <= 0.05 & is.cross(lon, lat, 2)),
                geom = "point", size = 0.2, alpha = 0.5) +
    scale_fill_divergent_discretised("SST", guide = guide_colorsteps_bottom(order = 2)) +
    scale_x_longitude() +
    scale_y_latitude() +
    scale_mag(guide = "none") +
    facet_grid(term ~ var, labeller = labeller(term = lab_cplx, 
                                               PC = c(PC1 = "EOF1", PC2 = "EOF2"))) +
    coord_quickmap(ylim = c(NA, 10)) +
    theme(legend.box = "horizontal") +
    # ggh4x::facet_nested(term ~ PC) +
    axis_labs_smol
}
```

```{r sst-psi-1,  fig.cap = "Regresión con PSI en 200 hPa y sst, PC1"}
plot_sst_psi(which_pc = "PC1", which_lev = 200)
```

```{r sst-psi-2,  fig.cap = "Regresión con PSI en 200 hPa y sst, PC1"}
plot_sst_psi(which_pc = "PC2", which_lev = 200)
```


```{r mean-psi, fig.cap = "mean streamfunction"}
psi %>% 
  .[lev == 200, .(psi.z = -mean(psi.z)), by = .(lon, lat)] %>% 
  .[, c("fx", "fy") := WaveFlux(.SD)] %>% 
  .[lat <= 10] %>% 
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = psi.z)) +
  geom_streamline(aes(dx = fx, dy = fy), min.L = 3, L = 10, n = 30,
                  size = 0.2, res = 2) +
  geom_qmap(keep = .015) +
  scale_fill_divergent(NULL, guide = guide_colorstrip_bottom(width = 15)) +
  scale_x_longitude() +
  scale_y_latitude()  +
  coord_quickmap(ylim = c(-90, 10))
```




### Precipitation



```{r cmap}
cmap <- ReadNetCDF(CMAP(), vars = c(pp = "precip"),
                   subset = list(lat = -90:10)) %>%
  normalise_coords() %>%
  .[, .(pp = mean(pp, na.rm = TRUE)), by = .(lon, lat, time = seasonally(time))]
```

```{r regr_pp}
regr_pp <- ceof[, eof[[1]]$left, by = season] %>%
  sep_ReIm(hgt, "wide") %>%
  .[, hgt := NULL] %>%
  .[, `:=`(R = R/sd(R), I = I/sd(I)), by = .(season, PC)] %>%
  .[melt(cmap, id.vars = c("lon", "lat", "time")), on = "time", allow.cartesian = TRUE] %>%
  .[season == "SON"] %>%
  .[, FitLm(value, I, R, se = TRUE), by = .(lon, lat, PC, variable, season)] %>%
  rm_intercept()
```


```{r add_continents}
continents <- list(africa  = list(lon = c(0, 60),
                                  lat = c(-40, 0)),
                   oceania = list(lon = c(100, 180),
                                  lat = c(-50, -13)),
                   america = list(lon = c(265, 325),
                                  lat = c(-60, -10)))

add_continent <- function(dt) {
  dt[, continent := fcase(lon %between% continents$africa$lon &
                            lat %between% continents$africa$lat, "africa",
                          lon %between% continents$oceania$lon &
                            lat %between% continents$oceania$lat, "oceania",
                          lon %between% continents$america$lon &
                            lat %between% continents$america$lat, "america")] %>%
    .[, continent := factor(continent, levels = c("africa", "oceania", "america"), ordered = TRUE)] %>%
    .[]
}
```


```{r plot_pp}
plot_pp <- function(data, which_pc, which_term = c("R", "I"), which_continent = NULL) {
  filter_continent <- function(data) {
    if (!is.null(which_continent)) {
    data[ continent == which_continent]  
    } else {
      data
    }
    
  }
  data %>%
    .[PC %in% which_pc] %>%
    .[term %in% which_term] %>%
    .[, lev := "sfc"] %>%
    .[lat >= -60] %>% 
    add_continent() %>%
    filter_continent() %>% 
    # .[abs(estimate) <= 2] %>% 
    .[, p_val := Pvaluate(estimate, std.error, df, "none"), by = .(lev, PC, term)] %>%
    periodic(lon = c(0, 360)) %>%
    ggplot(aes(lon, lat)) +
    # geom_raster(aes(fill = estimate)) +
    geom_contour_fill(aes(z = estimate, fill = ..level..), breaks = AnchorBreaks(exclude = 0)) +
    geom_contour_tanaka(aes(z = estimate), breaks = AnchorBreaks(exclude = 0)) +
    
    # scale_fill_divergent() +
    scale_fill_divergent_discretised(NULL, guide = guide_colorsteps_bottom(15)) +
    geom_contour2(aes(z = p_val), breaks = 0.05, size = 0.1) +
    stat_subset(aes(subset = p_val <= 0.05),
                geom = "point", size = 0.2) +
    geom_qmap(~.x %>% .[lat %between% c(-60, max(data$lat))] %>% add_continent() %>% filter_continent(),
              keep = 1) +
    
    scale_x_longitude(ticks = 15) +
    scale_y_latitude(ticks = 15) +
    ggh4x::facet_nested(term ~ PC, labeller = labeller(term = lab_cplx)) +
    axis_labs_smol +
    coord_quickmap()
}
```


```{r pp-america, fig.cap = "Regresión de cada PC con la precipitación"}
plot_pp(data = regr_pp, which_pc= c("PC1", "PC2"), which_continent =  "america")  
```



```{r pp-africa, fig.cap = "Regresión de cada PC con la precipitación"}
plot_pp(regr_pp, c("PC1", "PC2"), which_continent = "africa") 
```



```{r pp-oceania, fig.cap = "Regresión de cada PC con la precipitación"}
plot_pp(regr_pp, c("PC1", "PC2"), which_continent =  "oceania") 
```


# Conclusions



# References

<!-- The following line ensures the references appear here for the MS Word or HTML output files, rather than right at the end of the document (this will not work for PDF files):  -->

