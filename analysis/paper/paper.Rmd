---
title: "Title Goes Here"
author:
  - Myfirstname Mylastname:
      email: fl@oneplace.edu
      institute: [UofO]
      correspondence: true
  - Yourfirstname Yourlastname:
      email: fl@another.edu
      institute: [UofA]
      correspondence: false
institute:
  - UofO: University of One Place
  - UofA: University of Another Place
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  bookdown::pdf_document2:
    fig_height: 7.6
    fig_width: 12.8
  powerpoint_presentation:
    fig_height: 7.6
    fig_width: 12.8
    reference_doc: ../templates/template.pptx
bibliography: references.bib
csl: "../templates/journal-of-archaeological-science.csl" # Insert path for the bib-style
header-includes:
  - \usepackage{subfig}
# abstract: |
#   Text of abstract
# keywords: |
#   keyword 1; keyword 2; keyword 3
# highlights: |
#   These are the highlights. 
---

<!-- cambiarn nomenclatura. Imaginario / real -> pasarlo a nombrar la fase -->

<!-- Chequear con ncep -->

<!-- The following code chunk defines some general settings how code chunks should behave. -->

```{r setup, echo = FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  cache = TRUE,
  comment = "#>",
  cache.extra = 43,
  cache.path = "../cache/paper/",
  fig.path = "../figures/",
  dpi = 300,
  dev = c("pdf", "png")
)

library(metR)
library(data.table)
library(magrittr)
library(ggplot2)
library(tagger)
library(ggperiodic)
library(patchwork)
library(shceof)
library(kableExtra)


theme_set(theme_shceof(base_size = 16))

grid <- theme(panel.grid = element_line(color = "gray10", size = 0.4, linetype = 3))

guide_colorstrip_bottom <- function(width = 25, height = 0.5, ...) {
  guide_colorstrip(title.position = "top", title.hjust = 0.5,
                   barheight = height,
                   barwidth = width, ...)
}

guide_colorsteps_bottom <- function(width = 25, height = 0.5, ...) {
  guide_colorsteps(show.limits = TRUE, even.steps = FALSE,
                   title.position = "top", title.hjust = 0.5,
                   barheight = height,
                   barwidth = width, ...)
}

axis_labs_smol <- theme(axis.text = element_text(size = 6))

pattern_crosshatch <- ggplot2::ggproto("GeomCrosshatch", ggpattern::GeomPolygonPattern)


ggplot2::update_geom_defaults(pattern_crosshatch, 
                              list(pattern = "crosshatch",
                                   pattern_colour = "black",
                                   pattern_fill = "black",
                                   pattern_density = 0.01,
                                   pattern_alpha = 0.2,
                                   pattern_spacing = 0.02))

lab_lev <- AddSuffix(" hPa")
lab_cplx <- c(R = "Real", 
              I = "Imaginary")
lab_PC <- c(PC1 = "EOF1", 
            PC2 = "EOF2")

combine_lists <- function(...) {
  # browser(expr = length(x) != length(y))
  X <- list(...)
  names <- names(X[[1]])
  names(names) <- names
  lapply(names, function(n) {
    unlist(lapply(X, function(x) x[[n]]))
  })
}
```

```{r test-irlba}
has_irlba <- requireNamespace("rilba", quietly = TRUE)
if (has_irlba) {
  stop("If installed, metR::EOF uses irlba, but that package has a bug with complex matrices\n(see: https://github.com/bwlewis/irlba/issues/55). Uninstall irlba with renv::remove(\"irlba\") and try again.")
}

```

```{r read-data}
era5 <- ReadNetCDF(ERA5(), vars = c(hgt = "z",
                                    t = "t"),
                   subset = list(level = list(850, 700, 200, 50),
                                 latitude = -90:10)) %>% 
  normalise_coords() %>% 
  .[season(time) == "SON"] %>%
  .[, .(hgt = mean(hgt), 
        t = mean(t)), by = .(lev, lon, lat, time = seasonally(time))]
```

```{r compute-psi}
psi <- ReadNetCDF(ERA5(), vars = "vo",
                  subset = list(level = c(50, 200),
                                time = c("1979-01-01", "2019-12-01"))) %>%
  normalise_coords() %>%
  .[season(time) == "SON"] %>%
  .[, .(vo = mean(vo)), by = .(lon, lat, lev,time = seasonally(time))] %>%
  .[, solve_poisson(vo, lon, lat), by = .(lev, time)] %>%
  .[, psi.z := Anomaly(value), by = .(time, lev, lat)] %>%
  .[, value := NULL]
```

# Introduction

# Data & Methods

Whereas for traditional "real" PCA, each principal component is defined up to it's sign. In complex PCA, principal components are defined up to their phase [@horel1984].

ERA5, ERA5 BE, ERA 20C

# Results

No mostrar los EOFs no complejos. No tiene sentido mostralos si no se analizas. 

Las correlaciones entre PCs Podrían ir en una tabla. Quizás suplementaria. 

Relacionar 50hPa con vórtice polar? Temperatura también suma. 
En 50 el negativo es más intenso que el negativo. ¿Por qué?

Ver qué pasa con U con el EOF1.

En 200 no se ve la señal de jet de la temperatura ¿qué pasa más abajo? 
en 700 la anomalía de temp coincide más o menos con el geopotentical

ondas antes e la tempreatura 

Mostrar EOF espaciales.

Tirar ERA20C a la basura. ERA20c suplementaria?


Pp, ¿cuál es la regresión con SAM asim en 200 hPa?

```{r compute-eof-naive}
eof_naive <- era5[lev %in% c(50, 200) & lat %between% c(-90, -20)] %>% 
  # .[, hgt := Anomaly(hgt), by = .(season(time), lon, lat, lev)] %>%
  .[, hgt  := Anomaly(hgt)*sqrt(cos(lat*pi/180)), by = .(time, lev, lat)] %>% 
  .[, .(eof = list(EOF(hgt ~ time | lon + lat, n = 1:4, data = .SD, suffix = "EOF"))), by = lev]

explained <- eof_naive[, eof[[1]]$sdev, by = lev] %>% 
  .[order(lev, EOF)] %>% 
  .[, scales::percent(r2, accuracy = .1)]

```

```{r}

background_palette <- grDevices::colorRampPalette(c("white", scales::muted("red")), 
                                                  space = "Lab")

eof_naive[, eof[[1]]$left, by = lev] %>% 
  .[, item := paste(lev, EOF, sep = "_")] %>% 
  widyr::pairwise_cor(item, time, hgt) %>% 
  setDT() %>%
  # .[]
  .[tstrsplit(item1, "_")[[1]] != tstrsplit(item2, "_")[[1]], ] %>% 
  .[tstrsplit(item1, "_")[[1]] != 50] %>% 
  .[, item1 := tstrsplit(item1, "_")[[2]]] %>%
  .[, item2 := tstrsplit(item2, "_")[[2]]] %>% 
  .[, r2 := round(correlation^2, 2)] %>% 
  dcast(item1 ~ item2, value.var = "r2") %>% 
  setnames("item1", "200 hPa") %>% 
  kbl2(booktabs = TRUE, caption = "$R^2$ between pairs of EOFs of each level rounded to two decimals.") %>% 
  # add_header_above(c("", "50 hPa" = 4)) %>% 
  columns_spec(2:5,  background = spec_color(.table[[.col]], option = background_palette, 
                                              scale_from = c(0, 1)),
               color = ifelse(.table[[.col]] > .5, "white", "black")) %>% 
  add_header_above(c("", "50 hPa" = 4)) %>%
  kable_classic()
```

Figure \@ref(fig:cor-eof-naive-1) show the spatial pattern of the 4 leading EOF of zonal anomalies of geopotential height for 50 hPa and 200 hPa computed separately. The percentages XXX . At 50 hPa, EOF1 and EOF2 on one hand, and EOF3 and EOF4 on the other are clearly pairs of zonal waves with wave numbers 1 and 2-3 respectively shifted by 1/4 wavelength. That is, each group of two EOFs represents the same zonal wave structure that changes in magnitude and location. Similarly, at 200 hPa EOF2 and EOF3 represent the same zonal wave structure with wave number \~3.

Furthermore, the wave 1 pattern represented by the first two EOFs at 50 hPa is similar to the wave 1 pattern shown as the leading EOF at 200 hPa, and the wave 2-3 pattern represented by the third and fourth EOF at 50 hPa is similar to the wave 3 pattern present in EOF2 and EOF3 at 200 hPa. These similarities suggest some level of joint variability across levels. Figure \@ref(fig:cor-eof-naive-2) shows the coefficient of determination between temporal series of each EOF at each level. EOF3 and EOF4 at 50 hPa are highly correlated with EOF2 and EOF3 at 200 hPa. Not only each pair of EOFs represent a single structure within each level, but they represent a coherent pattern of variability between levels. Similarly, the leading EOF of each level are relatively highly correlated, again suggesting an unique mode of joint variability.

```{r compute-ceof}
invisible(
  ReadNetCDF(ERA5(), vars = c(hgt = "z"),
             subset = list(latitude = -90:10,
                           level = list(200, 50))) %>%
    normalise_coords() %>%
    .[season(time) == "SON"] %>%
    .[, .(hgt = mean(hgt)), by = .(lev, lon, lat, time = seasonally(time))] %>%
    .[, season := season(time)] %>%
    {
      ceof <<- .[, .(eof = list(compute_ceof(.SD))), by = .(season)]
      ceof_splitted <<-  .[, levs := lev] %>%
        .[, .(eof = list(compute_ceof(.SD, n = 1:3))), by = .(season, levs)]
      
    }
)
```

```{r corr-ceof-splitted}
ceof_splitted[, eof[[1]]$left, by = .(lev = levs)] %>%
  copy() %>%
  .[, mag := abs(hgt)] %>%
  .[, item := paste(lev, PC, sep = "_")] %>%
  widyr::pairwise_cor(item, time, mag) %>%
  setDT() %>%
  # .[]
  .[tstrsplit(item1, "_")[[1]] != tstrsplit(item2, "_")[[1]], ] %>%
  .[tstrsplit(item1, "_")[[1]] != 50] %>%
  .[, item1 := tstrsplit(item1, "_")[[2]]] %>%
  .[, item2 := tstrsplit(item2, "_")[[2]]] %>%
  .[, r2 := round(correlation^2, 2)] %>%
  dcast(item1 ~ item2, value.var = "r2") %>%
  setnames("item1", "200 hPa") %>%
  kbl2(booktabs = TRUE, caption = "$R^2$ of the absolute magnitude of complex EOFs between 200 hPa and 50 hPa computing EOF separatedly for each level. The high correlation between levels for the two leading EOFs justifies treating the pattern as a mode of covariability between the stratosphere and the troposphere and, thus, computing the EOFs using both levels at the same time.") %>%
  columns_spec(2:4, background = spec_color(.table[[.col]], option = background_palette,
                                            scale_from = c(0, 1)),
               color = ifelse(.table[[.col]] > .5, "white", "black")) %>% 
  add_header_above(c("", "50 hPa" = 3)) %>%
  kable_classic() 
```

```{r rotate_eofs}
rotate <- function(z, angle = 0) {
  complex(real = cos(angle), imaginary = sin(angle)) * z
}


box <- list(lon = c(150, 195),
            lat = c(-25, -5))

psi_box <- psi %>%
  .[lev == 200] %>%
  .[lat %between% box$lat & lon %between% box$lon] %>%
  .[, .(psi.z = weighted.mean(psi.z, cos(lat*pi/180))), by = .(time, lev)]

psi_box <- cut(ceof$eof[[1]], 2)$left %>%
  copy() %>%
  .[psi_box, on = "time"]


angles <- seq(-pi, pi, by = 1*pi/180)

rotations_pc1 <- lapply(angles, function(a) {
  ceof$eof[[1]]$left[PC == "PC1"] %>%
    copy() %>%
    .[, hgt := rotate(hgt, a)] %>%
    sep_ReIm() %>%
    .[, .(mean = mean(hgt)), by = part] %>%
    .[, rotation := a]
}) %>%
  rbindlist()


best_rotation_pc1 <- rotations_pc1[part == "Imaginary"][which.min(abs(mean))]$rotation


rotations_pc2 <- lapply(angles, function(a) {
  psi_box %>%
    .[, hgt2 := rotate(hgt, a)] %>%
    .[, .(R = cor(Re(hgt2), psi.z),
          I = cor(Im(hgt2), psi.z))] %>%
    .[, rotation := a]
}) %>%
  rbindlist()

best_rotation_pc2 <- rotations_pc2[which.min(abs(R^2))]$rotation


eof_rotated_left <- ceof$eof[[1]]$left %>%
  copy() %>%
  .[PC == "PC2", hgt := rotate(hgt, best_rotation_pc2)] %>%
  .[PC == "PC1", hgt := rotate(hgt, best_rotation_pc1)]

eof_rotated_right <-  ceof$eof[[1]]$right %>%
  copy() %>%
  .[PC == "PC2", hgt := rotate(hgt, best_rotation_pc2)] %>%
  .[PC == "PC1", hgt := rotate(hgt, best_rotation_pc1)]

ceof_unrotated <- copy(ceof)

ceof$eof[[1]]$left <- eof_rotated_left
ceof$eof[[1]]$right <- eof_rotated_right

ceof <- rbindlist(list(rotated = ceof,
                       unrotated = ceof_unrotated),
                  idcol = "rotation")

rotated <- function(x) x[rotation == "rotated"]
unrotated <- function(x) x[rotation == "unrotated"]
```

```{r check-rotation}
# Check that rotated and unrotated eofs
# predict the same fields (up to floating point errors)
bad_cells <- ceof[, predict(eof[[1]]), by = rotation] %>%
  .[, hgt := as.numeric(Re(hgt))] %>%
  dcast(time + lon + lat + lev ~ rotation, value.var = "hgt") %>%
  .[, dif := rotated - unrotated] %>%
  .[abs(rotated - unrotated)  > 1e-10]

if (nrow(bad_cells) != 0) {
  stop("Rotated and unrotated eofs are not equivalent!")
}

ceof <- ceof[rotation == "rotated"][, rotation := NULL][]
```

```{r define-plot_ceof}
plot_ceof <- function(data, n = 1:2, formula = lev  ~  PC) {
  
  gdata <- data[, cut(eof[[1]], n)$right, by = .(season)]
  
  var <- data[, cut(eof[[1]], n)$sdev, by = .(season)] %>%
    .[, setNames(paste0(PC, " (", scales::percent(r2), ")"),
                 PC)]
  
  gdata %>%
    ggperiodic::periodic(lon = c(0, 360)) %>%
    ggplot(aes(lon, lat)) +
    
    geom_contour_fill(aes(z = Re(hgt), fill = ..level..),
                      breaks = AnchorBreaks(0, 0.005, exclude = 0)) +
    geom_contour2(aes(z = Im(hgt),  linetype = factor(sign(..level..))),
                  breaks = AnchorBreaks(0, 0.005, exclude = 0)) +
    
    scale_fill_divergent_discretised(guide = "none") +
    
    
    geom_qmap(~ .x[lat <= -20]) +
    scale_x_longitude() +
    scale_y_latitude() +
    scale_linetype_manual(values = c("1" = 1, "-1" = 2), labels = c("1" = "+", "-1" = "-"),
                          guide = "none") +
    facet_grid(formula,
               labeller = labeller(lev = lab_lev,
                                   PC = var)) +
    coord_quickmap(ylim = c(NA, -20)) +
    theme(legend.title = element_blank())
}
```

```{r ceofs, fig.cap = "Leading 2 EOFs of zonal anomalies of geopotential height in 50 hPa and 200 hPa for the SON trimester and the period 1979 -- 2009.", fig.subcap = c("Spatial patterns. Real part in shading, imaginary part in contours.", "Temproal series."), fig.ncol = 1}
ceof[season == "SON"] %>%
  plot_ceof() +
  coord_polar() +
  axis_labs_smol +
  tag_facets(tag = "cr")

ceof %>%
  .[, eof[[1]]$left, by = season] %>%
  sep_ReIm(hgt) %>%
  .[season == "SON"] %>%
  # .[, hgt := scale(hgt), by = .(part, PC)] %>%
  ggplot(aes(time, hgt)) +
  geom_hline(yintercept = 0, size = 0.1, color = "gray30") +
  geom_line(aes(color = part)) +
  scale_x_datetime(NULL) +
  scale_y_continuous("EOF") +
  scale_color_brewer(NULL, palette = "Dark2") +
  facet_grid(PC ~ .) +
  theme(panel.spacing = grid::unit(1.5, "lines"))  +
  ggthemes::geom_rangeframe(sides = "lr", size = 0.1, color = "gray30")
```

Both observations motivate the decision of performing complex EOF jointly between levels. The computation of the EOFs was carried out using data from both levels at the same time, therefore, each complex EOF has a spatial part that depends on longitude, latitude and level, an a temporal part that depends only on time. Figures \@ref(fig:ceofs-1) and \@ref(fig:ceofs-2) show, respectively, the spatial and temporal parts of the first two leading complex EOFs of zonal anomalies of geopotential height at 50 hPa and 200 hPa. In the spatial patterns in Figure \@ref(fig:ceofs-1), the real (in shading) and the imaginary parts (in contour) are in quadrature by construction, so that each EOF describe a single wave-like pattern whose amplitude and position (i.e. phase) is controlled by the magnitude and argument of the complex temporal EOF.

The wave patterns described by these complex EOFs match the patterns seen in the navie EOFs of Figure \@ref(fig: cor-eof-naive-1): The first is a wave 1, while the second is a wave 3. Note that in Figure \@ref(fig:ceofs-2), the real part of EOF1 has non zero mean. This is due to th fact that the geopotential fields that enter into the algorithm are anomalies with respect to the zonal mean (shown in Figure \@ref(fig:mean-anom)), not the time mean. The real part of the first EOF is, therefore, capturing the mean zonally anomalous field and the variability that projects onto it.

```{r mean-anom, fig.cap = "Mean SON zonal geopotential height anomalies at (a) 50 hPa and (b) 200 hPa"}
# era5 %>%
#   .[, mean(-hgt), by = .(lon, lat, lev)] %>%
#   .[lev %in% c(50, 200)] %>%
#   .[lat <= -20] %>%
#   .[, V2 := V1 - mean(V1), by = .(lat, lev)] %>%
#   periodic(lon = c(0, 360)) %>%
#   ggplot(aes(lon, lat)) +
#   geom_contour_fill(aes(z = V2), global.breaks = FALSE, breaks = AnchorBreaks(exclude = 0)) +
#   geom_contour_tanaka(aes(z = V2), global.breaks = FALSE, breaks = AnchorBreaks(exclude = 0)) +
#   geom_qmap(~ .x[lat <= -20]) +
#   scale_fill_divergent(NULL, breaks = AnchorBreaks(exclude = 0),
#                        guide = guide_colorstrip_bottom()) +
#   scale_x_longitude() +
#   scale_y_latitude() +
#   facet_grid(~lev, labeller = labeller(lev = lab_lev)) +
#   coord_polar() +
#   axis_labs_smol +
#   tag_facets()
```

(ref:extended-series-cap) Temporal series extended using ERA5 back extended preliminary edition (period 1950 -- 1978) and ERA5 (period 1979 -- 2019) and ERA20C (period 1900 -- 2010). Each series is computed by projecting monthly geopotential height zonal anomalies standardised by level south of 20ºS onto the corresponding spatial pattern. In numbers, the coefficient of determination between the ERA20C-based series and the two ERA5-based series. The ERA5 + ERABC and the ERA20C series are centred and scaled using the mean and standard deviation for their period of overlap (1950 -- 2010).

```{r extended-series, fig.cap = "(ref:extended-series-cap)"}
pattern <- ceof$eof[[1]]$right %>%
  sep_ReIm() %>%
  setnames("hgt", "EOF")

era20c <- ERA20C() %>%
  ReadNetCDF(vars = c(hgt = "z"),
             subset = list(latitude = range(pattern$lat),
                           level = list(200, 50))) %>%
  normalise_coords() %>%
  .[season(time) == "SON"] %>%
  .[, .(hgt = mean(hgt)), by = .(lev, lon, lat, time = seasonally(time))] %>%
  .[, season := season(time)] %>%
  .[, hgt := hgt/sd(hgt), by = .(lev)] %>%
  .[pattern, on = .NATURAL, allow.cartesian = TRUE] %>%
  .[, .(hgt = weighted.mean(hgt*EOF, w = cos(lat*pi/180))),  by = .(part, PC, time)]

era_more <- ERA5_BE() %>%
  ReadNetCDF(vars = c(hgt = "z"),
             subset = list(latitude = range(pattern$lat),
                           level = list(200, 50))) %>%
  rbind(.,
        ReadNetCDF(ERA5(), vars = c(hgt = "z"),
                   subset = list(latitude = range(pattern$lat),
                                 level = list(200, 50)))) %>%
  normalise_coords() %>%
  .[season(time) == "SON"] %>%
  .[, .(hgt = mean(hgt)), by = .(lev, lon, lat, time = seasonally(time))] %>%
  .[, season := season(time)] %>%
  .[, hgt := hgt/sd(hgt), by = .(lev)] %>%
  .[pattern, on = .NATURAL, allow.cartesian = TRUE] %>%
  .[, .(hgt = weighted.mean(hgt*EOF, w = cos(lat*pi/180))),  by = .(part, PC, time)] %>%
  era20c[., on = c("part", "PC", "time")] %>%
  .[, hgt := (i.hgt - mean(i.hgt))/sd(i.hgt)*sd(hgt, na.rm = TRUE) + mean(hgt, na.rm = TRUE),
    by = .(part, PC)] %>%
  .[, i.hgt := NULL]


# Check that the extended index coincides with the
# original index.
cors <- era_more %>%
  .[sep_ReIm(ceof$eof[[1]]$left), on = c("time", "PC", "part")] %>%
  na.omit() %>%
  .[, cor(hgt, i.hgt), by = .(PC, part)]

if (any(cors$V1 < 0.98)) {
  stop("Extended indices didn't work!")
}

extended <- rbindlist(list(era20c = era20c,
                           era5 = era_more),  use.names = TRUE, idcol = "dataset")

trends <- extended %>%
  .[time %between% common_range(time, dataset)] %>%
  .[, FitLm(hgt, time, se = TRUE), by = .(dataset, part, PC)] %>%
  rm_intercept() %>%
  .[, p_val := Pvaluate(estimate, std.error, df)] %>%
  .[, p_report := report_p(p_val)]

trends_all <- extended %>%
  .[, FitLm(hgt, time, se = TRUE), by = .(dataset, part, PC)] %>%
  rm_intercept() %>%
  .[, p_val := Pvaluate(estimate, std.error, df)] %>%
  .[, p_report := report_p(p_val)]

periods <- range(extended[time %between% common_range(time, dataset)]$time)
periods <- c(periods[1], lubridate::as_datetime("1979-01-01"), periods[2])

correlations <- extended %>%
  dcast(time + PC + part ~ dataset, value.var = "hgt") %>%
  na.omit() %>% {
    d <- .
    rbind(
      d[, .(correlation = cor(era20c, era5)),
        by = .(PC, part, time = ifelse(year(time) >= 1979,
                                       as.character(mean(periods[2:3])),
                                       as.character(mean(periods[1:2]))))],
      
      d[, .(correlation = cor(era20c, era5)),
        by = .(PC, part)] %>%
        .[, time := as.character(mean(periods[c(1, 3)]))]
    )
  } %>%
  
  .[, time := lubridate::as_datetime(time)]



extended %>%
  copy() %>%
  .[, ref := time %between% common_range(time, dataset)] %>%
  .[, hgt := (hgt - mean(hgt[ref]))/sd(hgt[ref]), by = .(PC, part, dataset)] %>%
  .[, dataset_o := dataset] %>%
  # .[dataset == "era5", dataset := ifelse(year(time) < 1979, "era5be", "era5")] %>%
  ggplot(aes(time, hgt)) +
  # Zero line + rangeframe
  geom_hline(yintercept = 0, size = 0.1, color = "gray30") +
  ggthemes::geom_rangeframe(sides = "lr", size = 0.1, color = "gray30") +
  
  geom_line(aes(color = dataset)) +
  scale_alpha_manual(values = c(1, 0.2)) +
  # Correlations
  annotate("errorbarh", xmin = periods[1:2], xmax = periods[2:3], y = -2.7, size = 0.3) +
  annotate("errorbarh", xmin = periods[1], xmax = periods[3], y = -4, size = 0.3) +
  
  geom_label(data = correlations[time %in% range(time)],
             aes(y = -2.7, label = paste0("r²: ", signif(correlation^2, 2))),
             label.r = grid::unit(0, "lines"), label.size = 0) +
  geom_label(data = correlations[!(time %in% range(time))],
             aes(y = -4, label = paste0("r²: ", signif(correlation^2, 2))),
             label.r = grid::unit(0, "lines"), label.size = 0) +
  
  geom_smooth(data = ~.x[dataset == "era20c"],
              method = "lm", se = FALSE,  aes(color = dataset)) +
  geom_smooth(data = ~copy(.x)[time %between% common_range(time, dataset)],
              aes(color = dataset), method = "lm", se = FALSE) +
  
  scale_x_datetime(NULL, date_labels = "%Y",
                   breaks = function(x) sort(unique(c(scales::pretty_breaks()(x),
                                                      lubridate::as_datetime("1979-10-01"))))) +
  scale_y_continuous("Standarised EOF") +
  scale_color_brewer(NULL, palette = "Dark2", labels = c(era20c = "ERA20C",
                                                         era5 = "ERA5 BE"),
                     guide = guide_legend(override.aes = list(size = 1), order = 1)) +
  facet_grid(part ~ PC, labeller = labeller(PC = lab_PC)) +
  theme(panel.spacing = grid::unit(1.5, "lines"))  +
  tag_facets("cr")
```

```{r}

```

Figure \@ref(fig:extended-series) shows temporal series of the two complex EOFs extended beyond the satellite era using the preliminary ERA5 back extension going back to 1950 (which we call the "hybrid ERA5" reanalysis) and using ERA20C for the period 1900 -- 2010. The hybrid ERA5 series and the ERE20C series agree relatively well during the period of overlap, although correlations are higher in the satellite period. There is a downward trend in the real part of EOF1 in the hybrid reanalysis (Figure \@ref(fig:extended-series)a.1, p-value `r trends[part == "Real" & PC == "PC1" & dataset != "era20c"]$p_report` for the period 1950 -- 2010) that appears to be part of a long-term signal, judging by the statistically significant trend observed in the ERA20C reanalysis from 1900 to 2010 (p-value `r trends_all[part == "Real" & PC == "PC1" & dataset == "era20c"]$p_report`) with similar magnitude during the period of overlap.

The ERA20C time-series has a also significant upward linear trend in the imaginary part of EOF1 (Figure \@ref(fig:extended-series)a.2, p-value `r trends[part == "Imaginary" & PC == "PC1" & dataset == "era20c"]$p_report`. However, there is no trend in the hybrid dataset during the period of overlap (p-value `r trends[part == "Imaginary" & PC == "PC1" & dataset != "era20c"]$p_report`) and the correlations between the old and modern series are much poorer for this variable. This suggests that the observed trend is not robust.

There is no significant trend in any of the complex parts of EOF2. The correlations between the hybrid and ERA20C datasets are much higher than for the EOF1, which suggests that ERA20C could be used as a valid dataset to study this index in the past.

## Regression

```{r compute-regression}
regr <- ceof[, eof[[1]]$left, by = .(season)] %>%
  .[season == "SON"] %>%
  sep_ReIm(format = "wide") %>%
  .[, hgt := NULL] %>%
  .[, `:=`(R = as.numeric(scale(R)), I = as.numeric(scale(I))),
    by = .(season, PC)] %>%
  dcast(time ~ PC, value.var = c("R", "I")) %>%
  .[melt(era5, id.vars = c("time", "lon", "lat", "lev")), on = "time", allow.cartesian = TRUE] %>%
  .[lev %in% c(850, 700, 200, 50)] %>%
  # .[variable == "hgt"] %>%
  .[, FitLm(value, I_PC1, R_PC1, I_PC2, R_PC2, se = TRUE),
    by = .(lev, lon, lat, variable)] %>%
  .[, c("term", "PC") := tstrsplit(term, "_")] %>%
  rm_intercept() %>%
  .[, term := factor(term, levels = c("R", "I"), labels = c("Real", "Imaginary"))]
```

```{r define-plot_regr}
plot_regr <- function(data, which_PC, which_levs, which_var) {
  data <- data %>%
    .[ PC %in% which_PC] %>%
    .[variable == which_var]
  
  var_title <- switch(which_var,
                      hgt = "Geopotential height",
                      t = "Temperature")
  lab_pc <- c(PC1 = "EOF1", PC2 = "EOF2")
  
  
  if (length(which_PC) > 1) {
    facet <- ggh4x::facet_nested(PC ~  term)
  } else {
    facet <- ggh4x::facet_nested(lev ~ PC +  term, labeller = labeller(lev = lab_lev, PC = lab_pc))
  }
  
  if ("lev" %in% colnames(data)) {
    data <- data[lev %in% which_levs]
  } else {
    data[, lev := which_levs]
  }
  data[lat <= -20] %>%
    # .[term == "I" & lev == 50] %>%
    .[, p_val := Pvaluate(estimate, std.error, df, "fdr"), by = .(lev, PC, term)] %>%
    periodic(lon = c(0, 360)) %>%
    ggplot(aes(lon, lat)) +
    ditto(
      geom_contour_fill(aes(z = estimate), breaks = AnchorBreaks(exclude = 0), global.breaks = FALSE) +
        geom_contour_tanaka() +
        scale_fill_divergent(var_title, guide = guide_colorstrip_bottom())
    ) +
    
    geom_contour2(aes(z = p_val), breaks = 0.05, size = 0.1) +
    stat_subset(aes(subset = p_val <= 0.05 & is.cross(lon, lat, 1)),
                geom = "point", size = 0.2, alpha = 0.1) +
    geom_qmap(~ .x[lat <= -20]) +
    
    scale_x_longitude() +
    scale_y_latitude() +
    facet +
    coord_polar() +
    axis_labs_smol +
    tag_facets("rc")
}

```

(ref:eof1-regr-gh-cap) Regression coefficients of the real and imaginary part of the first complex EOF on SON geopotential height for the 1979 -- 2019 period. These coefficients come from multiple linear regression involving the real and imaginary part of both EFO2.

```{r eof1-regr-gh, fig.cap = "(ref:eof1-regr-gh-cap)"}
plot_regr(regr, "PC1", c(200, 50), "hgt")
```

Figure \@ref(fig:eof1-regr-gh) shows regression patterns of SON geopotential height on the real and imaginary part of the first EOF at 50 hPa and 200 hPa.

(ref:eof1-regr-t-cap) Same as Figure \@ref(fig:eof1-regr-gh) but for air temperature.

```{r eof1-regr-t, fig.cap = "(ref:eof1-regr-t-cap)"}
plot_regr(regr, "PC1", c(200, 50), "t")
```

(ref:eof2-regr-gh-cap) Same as Figure \@ref(fig:eof1-regr-gh) but for the second EOF.

```{r eof2-regr-gh, fig.cap = "(ref:eof2-regr-gh-cap)"}
plot_regr(regr, "PC2", c(200, 50), "hgt")
```

(ref:eof2-regr-t-cap) Same as Figure \@ref(fig:eof1-regr-gh) but for the second EOF and temperature.

```{r eof2-regr-t, fig.cap = "(ref:eof2-regr-t-cap)"}
plot_regr(regr, "PC2", c(200, 50), "t")
```

```{r zonal-waves, fig.cap = "Amplitud de ondas zonales de la regresión con altura geopotencial (figuras anteriores)"}
regr %>%
  .[lat <= -20] %>%
  .[lev %in% c(200, 50)] %>%
  # .[PC == "PC1"] %>%
  .[, FitWave(estimate, 0:3), by = .(lev, PC, term, lat)] %>%
  ggplot(aes(lat, amplitude)) +
  geom_line(aes(color = factor(k))) +
  ggh4x::facet_nested(lev + PC ~ term, scales = "free") +
  scale_color_brewer("Wavenumber", palette = "Dark2") +
  scale_y_continuous("Amplitude") +
  scale_x_latitude() +
  coord_flip()
```

Interpretaciones:

-   Parte real de EOF1: variabilidady que se proyecta en la dirección del campo medio

-   Parte imaginaria de EOF1: variabilidad asociada a la parte simétrica del SAM

-   EOF2: PSA1 y PSA2.\

-   Parte imaginaria: proyecta sobre la parte asimétrica del SAM (PSA2)

-   Parte real: relativamente independiente del SAM

El primer EOF es esencialmente una medida de la variabilidad proyectada en la dirección el campo medio. La parte importante, de todas formas, es la Real.

## Relationship with other indices

### SAM

```{r read-indices}
sam <- "/home/elio/Documents/CONICET/asymsam/analysis/data/derived_data/indexes.Rds" %>%
  readRDS() %>%
  .[, .(time, sam = -estimate_norm, lev, symmetry = term)] %>%
  .[, sam := sam/sd(sam), by = .(lev, symmetry)] %>%
  .[season(time) == "SON"] %>%
  .[, .(sam = mean(sam)), by = .(symmetry, lev, time = seasonally(time))]



enso <- rsoi::download_oni(TRUE, data_path("raw", "oni.csv")) %>%
  as.data.table() %>%
  .[, .(time = lubridate::as_datetime(Date), oni = ONI)] %>%
  na.omit() %>%
  .[season(time) == "SON"] %>%
  .[, .(oni = mean(oni)), by = .(time = seasonally(time))]

plot_with_index <- function(ceof, index) {
  index_col <- colnames(index)[2]
  
  ceof[, eof[[1]]$left] %>%
    sep_ReIm() %>%
    .[, hgt := scale(hgt), by = .(PC, part)] %>%
    index[., on = "time"] %>%
    na.omit() %>%
    .[, index := get(index_col)] %>%
    ggplot(aes(hgt, index)) +
    geom_point(aes(color = part)) +
    geom_smooth(aes(color = part), method = "lm") +
    shadowtext::geom_shadowtext(data = ~.x[, .(cor = cor(index, hgt),
                                               x = -1.2,
                                               y = sign(-cor(index, hgt))*.1 + predict(lm(index ~ hgt),
                                                                                       newdata = data.frame(hgt = -1.2))),
                                           by = .(PC, part)],
                                bg.colour = "white", bg.r = 0.2,
                                size = 5, show.legend = FALSE,
                                aes(x, y, color = part, label = paste0("r² = ", round(cor^2, 2)))) +
    scale_x_continuous("EOF") +
    scale_y_continuous(toupper(index_col)) +
    scale_color_brewer("Part", palette = "Dark2") +
    facet_grid(part ~ PC, labeller = labeller(PC = c(PC1 = "EOF1", PC2 = "EOF2")))
}
```

(ref:sam-eof-vertical-cap) Coefficient of determination between the real and imaginary part of each EOF and the SAM, Asymmetric SAM (A-SAM) and Symmetric SAM (S-SAM) indices computed at each level according to @campitelli2021. Points mark estimates with p-value \< 0.01 corrected for False Detection Rate [@benjamini1995].

```{r sam-eof-vertical, fig.cap = "(ref:sam-eof-vertical-cap)"}
time <- ceof[, eof[[1]]$left, by = .(season)] %>%
  sep_ReIm() %>%
  .[, hgt := scale(hgt), by = .(PC, part)] %>%
  .[]

sams <- readRDS(data_path("derived", "sam.Rds")) %>%
  .[season(time) == "SON"] %>%
  .[, dim :=  lubridate::days_in_month(time)] %>%
  .[, .(estimate = weighted.mean(estimate, dim)),
    by = .(lev, term, time = seasonally(time))]

sam_r2 <- sams %>%
  .[time, on = .NATURAL, allow.cartesian = TRUE] %>%
  .[, correlate(hgt, estimate), by = .(lev, term, part, PC)]

max_r2 <- sam_r2[part == "Imaginary" & term == "asym"][, .SD[which.max(estimate^2)],
                                                       by = .(PC)]

sam_r2 %>%
  ggplot(aes(lev, estimate^2)) +
  # geom_ribbon(data =  ~.x[p.adjust(p_value, "fdr") < 0.001],
  # aes(ymin = low2, ymax = high2, color = term), alpha= 0.1) +
  geom_point(data = ~.x[p.adjust(p.value, "fdr") < 0.01], aes(color = term)) +
  geom_line(aes(color = term, size = term)) +
  scale_x_level() +
  scale_y_continuous("r²", limits = c(0, 1)) +
  scale_size_manual(guide = "none",
                    values = c(full = 1.2,
                               asym = 0.5,
                               sym = 0.5)) +
  scale_color_brewer(NULL, palette = "Dark2", labels = c(full = "SAM",
                                                         asym = "A-SAM",
                                                         sym = "S-SAM")) +
  facet_grid(part ~ PC, labeller = labeller(PC = c(PC1 = "EOF1", PC2 = "EOF2"))) +
  coord_flip() +
  tag_facets("rc")
```

Figure \@ref(fig:sam-eof-vertical) shows the coefficient of determination between the EOFs and three SAM indices. The SAM index represents the leading EOF of monthly geopotential height fields south of 20ºS at each level. The A-SAM and S-SAM indices represent, respectively, the zonally asymmetric and symmetric component of the SAM and are obtained by projecting the zonally asymmetric and zonally symmetric part of the SAM spatial pattern onto monthly geopotential height fields (@campitelli2021). Since the analysis here is only for the SON trimester, monthly values were averaged across semesters (weighted by the number of days in each month).

Both EOFs bear some modest relationship with the SAM index (thick green line in Figure \@ref(fig:sam-eof-vertical)), although not statistically significant at every level. The split between A-SAM and S-SAM gives more insight into the nature of the relationship. The relationship between the SAM and the imaginary EOF1 (Figure \@ref(fig:sam-eof-vertical).b1) is mediated by S-SAM in the troposphere, but by the A-SAM in the stratosphere.

The Imaginary EOF2 is related with the SAM through the A-SAM in the troposphere, with up to `r scales::percent(max_r2[PC == "PC2"]$estimate, 2)` of shared variance, reached at `r max_r2[PC == "PC2"]$lev` hPa (Figure \@ref(fig:sam-eof-vertical).b2). The Imaginary EOF2 is, then, an almost a pure representation of the tropospheric asymmetric part of the SAM. Since the Real EOF2 represents a quarter-wavelength rotation of the same zonal wave 3 structure, the Imaginary part is the phase that coincides with the SAM. As a corollary, this means that the asymmetric component of the SAM represents only one phase of a zonally varying zonal wave.

```{r regr_psi}
regr_psi <- ceof[, eof[[1]]$left, by = .(season)] %>%
  sep_ReIm(hgt, "wide") %>%
  .[, hgt := NULL] %>%
  .[, `:=`(R = R/sd(R), I = I/sd(I)), by = .(season, PC)] %>%
  .[psi, on = "time", allow.cartesian = TRUE] %>%
  .[season(time) == "SON"] %>%
  .[, FitLm(psi.z, R, I, se = TRUE),by = .(lon, lat, lev, PC, season)] %>%
  rm_intercept() %>%
  .[, psi.z := estimate] %>%
  .[, c("fx", "fy") := shceof::WaveFlux(.SD, p = 200), by = .(lev, PC, season, term)] %>%
  .[, term := factor(term, levels = c("R", "I"), labels = c("Real", "Imaginary"),
                     ordered = TRUE)]
```

```{r sst}
sst <- ERA5_SST() %>%
  ReadNetCDF(vars = c("t" = "sst")) %>%
  normalise_coords() %>%
  .[season(time) == "SON"] %>%
  .[, .(t = mean(t)), by = .(lon, lat, time = seasonally(time))]
```

```{r regr_sst}
regr_sst <- ceof[, eof[[1]]$left, by = .(season)] %>%
  sep_ReIm(hgt, "wide") %>%
  .[, hgt := NULL] %>%
  .[, `:=`(R = R/sd(R), I = I/sd(I)), by = .(season, PC)] %>%
  .[sst, on = "time", allow.cartesian = TRUE] %>%
  .[season(time) == "SON"] %>%
  .[, FitLm(t, I, R, se = TRUE), by = .(lon, lat, PC, season)] %>%
  rm_intercept() %>%
  .[, term := factor(term, levels = c("R", "I"), labels = c("Real", "Imaginary"),
                     ordered = TRUE)]
```

```{r plot_sst_psi}
plot_sst_psi <- function(which_pc, which_lev) {
  sst_gdata <- regr_sst[PC == which_pc] %>%
    .[lat %between% c(-90, 10)] %>%
    .[, p_val := Pvaluate(estimate, std.error, df, "fdr"), by = .(PC, term)] %>%
    .[, var := "SST"]
  
  regr_psi %>%
    .[PC == which_pc] %>%
    .[lev == which_lev] %>%
    # .[abs(estimate) > 1, estimate := NA] %>%
    .[lat %between% c(-90, 10)] %>%
    .[, p_val := Pvaluate(estimate, std.error, df, "fdr"), by = .(PC, term)] %>%
    .[, var := "Streamfunction"] %>%
    periodic(lon = c(0, 360)) %>%
    ggplot(aes(lon, lat)) +
    geom_contour_fill(aes(z = estimate*1e8, fill = ..level..),
                      breaks = AnchorBreaks(exclude = 0)) +
    geom_contour2(aes(z = p_val), breaks = 0.05, size = 0.1) +
    stat_subset(aes(subset = p_val <= 0.05 & is.cross(lon, lat, 1)),
                geom = "point", size = 0.2, alpha = 0.5) +
    geom_streamline(aes(dx = fx, dy = fy), min.L = 3, L = 10, n = 30,
                    size = 0.2, res = 2) +
    geom_qmap(keep = .015) +
    scale_fill_divergent_discretised("Streamfunction", guide = "none") +
    ggnewscale::new_scale_fill() +
    
    geom_contour_fill(data = sst_gdata,
                      aes(z = estimate, fill = ..level..), breaks = AnchorBreaks(exclude = 0)) +
    geom_contour_tanaka(data = sst_gdata,
                        aes(z = estimate), breaks = AnchorBreaks(exclude = 0)) +
    geom_contour2(data = sst_gdata,
                  aes(z = p_val), breaks = 0.05, size = 0.1) +
    stat_subset(data = sst_gdata,
                aes(subset = p_val <= 0.05 & is.cross(lon, lat, 3)),
                geom = "point", size = 0.2, alpha = 0.5) +
    scale_fill_divergent_discretised("SST", guide = guide_colorsteps_bottom(order = 2)) +
    scale_x_longitude() +
    scale_y_latitude() +
    scale_mag(guide = "none") +
    facet_grid(term ~ var, labeller = labeller(PC = c(PC1 = "EOF1", PC2 = "EOF2"))) +
    coord_quickmap(ylim = c(NA, 10)) +
    theme(legend.box = "horizontal") +
    # ggh4x::facet_nested(term ~ PC) +
    axis_labs_smol +
    tag_facets("cr", position = "bl")
}
```

```{r enso_cor}
enso_cor <-  ceof[, eof[[1]]$left, by = .(season)] %>%
  sep_ReIm() %>%
  .[, hgt := scale(hgt), by = .(PC, part)] %>%
  enso[., on = "time"] %>%
  na.omit() %>%
  .[, correlate(hgt, oni), by = .(PC, part)]
```

```{r sst-psi-2,  fig.cap = "Regresión con PSI en 200 hPa y sst, PC1"}
plot_sst_psi(which_pc = "PC2", which_lev = 200)
```

??? -\> esta intro hay que cambiarla. Figure \@ref(fig:sst-psi-2) shows regression maps between EOF2 and Sea Surface Temperatures (SST) Streamfunction at 200 hPa. The Imaginary EOF2 is associated with strong negative SST anomalies on the Central Pacific and positive anomalies on an area across the North of Australia and New Zealand, the South Pacific Convergence Zone (SPCZ) (Figure \@ref(fig:sst-psi-2).a2). This pattern is almost canonically negative ENSO and indeed, the correlation between the Imaginary EOF2 and the Oceanic ENSO Index ([@bamston1997]) is `r enso_cor[PC == "PC2" & part == "Imaginary"]$cor_text`. Streamfunction anomalies show a coherent picture. The Imaginary EOF2 is associated with strong wave-like streamfunction anomalies emanating from the tropics (Figure \@ref(fig:sst-psi-2).b2). . This is consistent with what we know of the effect of ENSO on the extratropics: SST anomalies initiate anomalous convection that excites meridionally-moving Rossby waves.

One could expect that the Real EOF2, being just a different phase of the same wave train would show a similar pattern but, perhaps with a slight translation of the main tropical sources. However, the Real EOF2 is associated neither with any significant SST (Figure \@ref(fig:sst-psi-2).a1) nor streamfunction anomalies in the tropics. The correlation between the Real EOF2 and ENSO is also not significant (`r enso_cor[PC == "PC2" & part == "Real"]$cor_text`).

```{r enso-phase, fig.cap = "Relationship between ENSO and phase of EOF2 for the period 1979 -- 2019. Colours denote years with magnitude of EOF2 greater or smaller than the 50th percentile. Black line is the fit ONI ~ cos(phase) + sin(phase) computed by OLS weighted by the magnitude of EOF2."}
cor_enso_mag <- ceof[, eof[[1]]$left, by = .(season)] %>%
  .[, arg := Arg(hgt)] %>%
  .[, mag := Mod(hgt)] %>%
  .[enso, on = "time"] %>%
  na.omit() %>%
  .[PC == "PC2"] %>%
  .[, correlate(mag, abs(oni))]

ceof[, eof[[1]]$left, by = .(season)] %>%
  .[, arg := Arg(hgt)] %>%
  .[, mag := Mod(hgt)] %>%
  .[enso, on = "time"] %>%
  na.omit() %>%
  .[PC == "PC2"] %>%
  ggplot(aes(arg, oni)) +
  geom_hline(yintercept = c(-0.5, 0, 0.5), size = 0.2, color = "gray50") +
  geom_vline(xintercept = 0, size = 0.2, color = "gray50") +
  annotate(shadowtext:::GeomShadowText,
           label = c("- Real", "- Imaginary", "+ Real", "+ Imaginary"),
           color = "gray60", bg.colour = "white", bg.r = 0.2,
           size = 6,
           y = -2, x = c(-pi, -pi/2, 0, pi/2), angle = 90, hjust = 0) +
  
  geom_smooth(data = ~qwrap(.x, arg = c(-pi, pi) ~ c(-2*pi, 2*pi)),
              method = "lm", aes(weight = mag),
              formula = y ~  I(cos(x)) + I(sin(x)),
              se = FALSE, color = "black", size = 0.5) +
  geom_point(aes(colour = mag >= quantile(mag, 0.5),
                 shape  = mag >= quantile(mag, 0.5)),
             size = 4) +
  
  scale_color_brewer(NULL, palette = "Dark2",
                     labels = c("TRUE"  = "|EOF2| > 50%",
                                "FALSE" = "|EOF2| < 50%")) +
  scale_shape_manual(NULL, values = c("TRUE" = 20,
                                      "FALSE" = 18),
                     labels = c("TRUE"  = "|EOF2| > 50%",
                                "FALSE" = "|EOF2| < 50%")) +
  scale_y_continuous("ONI") +
  scale_x_continuous("Phase",
                     breaks = seq(-pi, pi, by = 30*pi/180),
                     labels = function(x) paste0(round(x*180/pi, 5), "º")) +
  coord_cartesian(xlim = c(-pi, pi))
```

We show a more complete picture of the relationship between ENSO and EOF2 in Figure \@ref(fig:enso-phase), which plots the ONI index value and the phase of the EOF2 for each year between 1979 and 2019 highlighting years in which the magnitude of EOF2 was higher than 50% of the years. In years with positive ENSO, the phase of the EOF2 is always around -90º (corresponding with negative imaginary part) and vice versa. In years with near neutral ENSO, the phase of the EOF2 is much more variable between 0º and -180º. There is also a relationship between the magnitude of the EOF2 and the magnitude of the ENSO. The strong EOF2 years are almost invariably associated with strong ENSO years. The correlation between the absolute magnitude of the ONI and the magnitude of the EOF2 is `r cor_enso_mag$cor_text`.

All this suggests that the wave train represented by EOF2 can be both forced by tropical SSTs and also a part of the internal variability of the extratropical atmosphere. When internally forced, there is little phase preference and amplitudes are relatively low. However, this same wave train, when excited by tropical SST anomalies will prefer the imaginary phase, with the sign of the geopotential anomalies depending on the sign of the tropical SSTs anomalies, and can reach higher magnitudes.

```{r  sst-psi-1, fig.cap = "Same as figure befoe but for EOF1"}
plot_sst_psi(which_pc = "PC1", which_lev = 200)
```

```{r}
psi %>%
  .[lev == 200] %>%
  .[, .(psi.z = mean(psi.z)), by = .(lon, lat)] %>%
  .[, c("fx", "fy") := WaveFlux(.SD)] %>%
  .[lat <= 0] %>%
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = psi.z)) +
  geom_streamline(aes(dx = fx, dy = fy)) +
  geom_qmap(~.x[lat<0], keep = .015) +
  scale_fill_divergent()
```

## Precipitation

```{r cmap}
cmap <- ReadNetCDF(CMAP(), vars = c(pp = "precip"),
                   subset = list(lat = -90:10)) %>%
  normalise_coords() %>%
  .[, .(pp = mean(pp, na.rm = TRUE)), by = .(lon, lat, time = seasonally(time))]
```

```{r regr_pp}
regr_pp <- ceof[, eof[[1]]$left, by = season] %>%
  sep_ReIm(hgt, "wide") %>%
  .[, hgt := NULL] %>%
  .[, `:=`(R = R/sd(R), I = I/sd(I)), by = .(season, PC)] %>%
  .[melt(cmap, id.vars = c("lon", "lat", "time")), on = "time", allow.cartesian = TRUE] %>%
  .[season == "SON"] %>%
  .[, FitLm(value, I, R, se = TRUE), by = .(lon, lat, PC, variable, season)] %>%
  rm_intercept()
```

```{r add_continents}
continents <- list(africa  = list(lon = c(0, 60),
                                  lat = c(-40, 0)),
                   oceania = list(lon = c(100, 180),
                                  lat = c(-50, -13)),
                   america = list(lon = c(265, 325),
                                  lat = c(-60, -10)))

add_continent <- function(dt) {
  dt[, continent := fcase(lon %between% continents$africa$lon &
                            lat %between% continents$africa$lat, "africa",
                          lon %between% continents$oceania$lon &
                            lat %between% continents$oceania$lat, "oceania",
                          lon %between% continents$america$lon &
                            lat %between% continents$america$lat, "america")] %>%
    .[, continent := factor(continent, levels = c("africa", "oceania", "america"), ordered = TRUE)] %>%
    .[]
}
```

```{r plot_pp}
plot_pp <- function(data, which_pc, which_term = c("R", "I"), which_continent = NULL) {
  filter_continent <- function(data) {
    if (!is.null(which_continent)) {
      data[ continent == which_continent]
    } else {
      data
    }
    
  }
  data %>%
    .[PC %in% which_pc] %>%
    .[term %in% which_term] %>%
    .[, lev := "sfc"] %>%
    .[lat >= -60] %>%
    add_continent() %>%
    filter_continent() %>%
    # .[abs(estimate) <= 2] %>%
    .[, p_val := Pvaluate(estimate, std.error, df, "none"), by = .(lev, PC, term)] %>%
    periodic(lon = c(0, 360)) %>%
    ggplot(aes(lon, lat)) +
    # geom_raster(aes(fill = estimate)) +
    geom_contour_fill(aes(z = estimate, fill = ..level..), breaks = AnchorBreaks(exclude = 0)) +
    geom_contour_tanaka(aes(z = estimate), breaks = AnchorBreaks(exclude = 0)) +
    
    # scale_fill_divergent() +
    scale_fill_divergent_discretised(NULL, guide = guide_colorsteps_bottom(15)) +
    geom_contour2(aes(z = p_val), breaks = 0.05, size = 0.1) +
    stat_subset(aes(subset = p_val <= 0.05),
                geom = "point", size = 0.2) +
    geom_qmap(~.x %>% .[lat %between% c(-60, max(data$lat))] %>% add_continent() %>% filter_continent(),
              keep = 1) +
    
    scale_x_longitude(ticks = 15) +
    scale_y_latitude(ticks = 15) +
    ggh4x::facet_nested(term ~ PC, labeller = labeller(term = lab_cplx)) +
    axis_labs_smol +
    coord_quickmap()
}
```

```{r pp-america, fig.cap = "Regresión de cada PC con la precipitación"}
plot_pp(data = regr_pp, which_pc= c("PC1", "PC2"), which_continent =  "america")
```

```{r pp-africa, fig.cap = "Regresión de cada PC con la precipitación"}
plot_pp(regr_pp, c("PC1", "PC2"), which_continent = "africa")
```

```{r pp-oceania, fig.cap = "Regresión de cada PC con la precipitación"}
plot_pp(regr_pp, c("PC1", "PC2"), which_continent =  "oceania")
```

# Conclusions

# Appendix

## Naive EOFs

(ref:cap-eof-naive) Leading 4 EOFs of zonal anomalies of geopotential height at 50 hPa and 200 hPa for the SON trimester and the period 1979 -- 2009.

(ref:subcap-eof-naive) Spatial patterns (arbitrary units). The numbers at the top-left of each panel is the variance explained by each EOF.

(ref:subcap-cor-eof-naive) Coefficient of determination of the temporal index of each EOF between levels.

```{r cor-eof-naive, fig.cap = "(ref:cap-eof-naive)", fig.subcap = c("(ref:subcap-eof-naive)", "(ref:subcap-cor-eof-naive)"), fig.ncol = 1}
eof_naive[, eof[[1]]$right, by = lev] %>%
  periodic(lon = c(0, 360)) %>%
  ggplot(aes(lon, lat)) +
  
  geom_contour_fill(aes(z = hgt, fill = ..level..),
                    breaks = AnchorBreaks(0, 0.01, exclude = 0)) +
  geom_contour_tanaka(aes(z = hgt), breaks = AnchorBreaks(0, 0.01, exclude = 0)) +
  
  geom_qmap(~.x[lat <= -20]) +
  scale_fill_divergent_discretised(guide = "none")  +
  scale_y_latitude() +
  scale_x_longitude() +
  coord_polar() +
  facet_grid(lev~EOF, labeller = labeller(lev = lab_lev))  +
  axis_labs_smol +
  tagger::tag_facets(tag = "panel", tag_pool = explained, tag_suffix = "")


eof_naive[, eof[[1]]$left, by = lev] %>%
  .[, item := paste(lev, EOF, sep = "_")] %>%
  widyr::pairwise_cor(item, time, hgt) %>%
  setDT() %>%
  # .[]
  .[tstrsplit(item1, "_")[[1]] != tstrsplit(item2, "_")[[1]], ] %>%
  .[tstrsplit(item1, "_")[[1]] != 50] %>%
  .[, item1 := tstrsplit(item1, "_")[[2]]] %>%
  .[, item2 := tstrsplit(item2, "_")[[2]]] %>%
  ggplot(aes(item1, item2)) +
  geom_raster(aes(fill = correlation^2)) +
  shadowtext::geom_shadowtext(aes(label = round(correlation^2, 2)),
                              color = "black", bg.colour = "white", bg.r = 0.2) +
  scale_fill_gradient(guide = "none", low = "white", high = scales::muted("red"), limits = c(0, 1)) +
  scale_x_discrete("200 hPa") +
  scale_y_discrete("50 hPa") +
  plot_layout(ncol = 1)
```

## Chosen rotations of the EOFs

```{r rotations-pc1, fig.cap = "Rotations of PC1"}
rotations_pc1 %>%
  ggplot(aes(rotation, mean)) +
  geom_hline(yintercept = 0, color = "gray") +
  geom_line(aes(color = part), size = 1) +
  scale_x_continuous("Rotation", breaks = seq(-pi, pi, by = 30*pi/180),
                     labels = function(x) paste0(round(x*180/pi, 5), "º")) +
  scale_y_continuous("Mean value") +
  scale_color_brewer(NULL, palette = "Dark2", labels = lab_cplx)
```

```{r regr-rotation, fig.cap = "Regression with streamfunction PC2"}
regr_psi %>%
  .[PC == "PC2"] %>%
  .[lev == 200] %>%
  .[lat %between% c(-90, 10)] %>%
  periodic(lon = c(0, 360)) %>%
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = estimate*1e8, fill = ..level..),
                    breaks = AnchorBreaks(exclude = 0)) +
  geom_contour_tanaka(aes(z = estimate*1e8),
                      breaks = AnchorBreaks(exclude = 0)) +
  
  geom_qmap(keep = .015) +
  scale_fill_divergent_discretised("Streamfunction", guide = "none") +
  
  scale_x_longitude() +
  scale_y_latitude() +
  scale_mag(guide = "none") +
  facet_grid(term ~ ., labeller = labeller(PC = c(PC1 = "EOF1", PC2 = "EOF2"))) +
  coord_quickmap(ylim = c(NA, 10)) +
  theme(legend.box = "horizontal") +
  axis_labs_smol +
  annotate("rect",
           xmin = box$lon[1], xmax = box$lon[2],
           ymin = box$lat[1], ymax = box$lat[2], color = "black", fill = NA)
```

```{r rotations-pc2, fig.cap = "R2 between EOF2 Real and Imaginary parts and zonal anomalies of streamfunction at BOX?? for different rotation parameters of the real and imaginary parts."}
rotations_pc2 %>%
  melt(id.vars = "rotation") %>%
  ggplot(aes(rotation, value^2)) +
  geom_hline(yintercept = 0, color = "gray") +
  geom_line(aes(color = variable), size = 1) +
  scale_x_continuous("Rotation", breaks = seq(-pi, pi, by = 30*pi/180),
                     labels = function(x) paste0(round(x*180/pi, 5), "º")) +
  scale_y_continuous("r^2") +
  scale_color_brewer(NULL, palette = "Dark2", labels = lab_cplx)
```

# References

<!-- The following line ensures the references appear here for the MS Word or HTML output files, rather than right at the end of the document (this will not work for PDF files):  -->
